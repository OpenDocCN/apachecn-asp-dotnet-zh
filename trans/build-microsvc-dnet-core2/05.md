# 部署微服务

整体和微服务架构风格都有不同的部署挑战。就……而言。NET 单片应用程序，更常见的是，部署是 Xcopy 部署的一种风格。微服务部署带来了一系列不同的挑战。持续集成和持续部署是交付微服务应用的关键实践。此外，承诺更大隔离边界的容器技术和工具链技术对于微服务部署和扩展至关重要。

在本章中，我们将讨论微服务部署的基础以及新兴实践(如 CI/CD 工具和容器)对微服务部署的影响。我们还将通过简单的部署。Docker 容器中的核心服务。

本章结束时，您将了解以下主题:

*   部署术语
*   微服务部署成功的因素是什么？
*   什么是持续集成和持续部署？
*   微服务部署的隔离要求
*   容器化技术及其对微服务部署的需求
*   快速介绍 Docker
*   如何使用 Visual Studio 将应用程序打包为 Docker 容器

在继续下一步之前，我们应该首先了解我们为什么谈论微服务的部署。部署周期是一个有特定流程的周期。

# 单一应用程序部署挑战

单片应用程序是指所有的数据库和业务逻辑都绑定在一起并打包成一个系统的应用程序。一般来说，由于单个应用程序是作为一个包来部署的，因此部署有些简单，但却很痛苦，原因如下:

*   作为单一概念的部署和发布:在部署构建工件和实际向最终用户提供特性之间没有区别。更常见的情况是，版本与其环境相结合。这增加了部署新功能的风险。
*   全有或全无部署:全有或全无部署会增加应用程序宕机和故障的风险。在回滚的情况下，团队无法交付预期的新功能，必须发布修补程序或服务包来交付正确的功能。

A **Hotfix**, also known as a **Quickfix**, is a single or cumulative package (generally called a **patch**). It contains fixes for issues/bugs found in production that must be fixed before the next major release. 

*   中央数据库作为单点故障:在单体应用程序中，大型集中式数据库是单点故障。这个数据库通常很大，很难分解。这导致**平均恢复时间** ( **MTTR** )和**平均故障间隔时间** ( **MTBF** )增加。
*   部署和发布是大事件:由于应用程序中的小变化，整个应用程序可能会被部署。这给开发人员和运营团队带来了巨大的时间和精力投入。不用说，不同团队之间的协作是成功发布的关键。当遍布全球的许多团队都在开发和发布时，这变得更加困难。这些类型的部署/发布需要大量的手动步骤。这影响了不得不面临应用程序停机的最终客户。如果你熟悉这些类型的部署，那么你也会熟悉所谓的作战室中的马拉松式会议和会议桥上无休止的缺陷分类会议。
*   上市时间:在这种情况下，对系统进行任何更改都会变得更加困难。在这样的环境中，执行任何业务变更都需要时间。这使得应对市场力量变得困难——企业也可能失去市场份额。借助微服务架构，我们正在应对其中一些挑战。这种体系结构为服务部署提供了更大的灵活性和隔离性。事实证明，它提供了更快的周转时间和急需的业务敏捷性。

# 理解部署术语

微服务部署术语仅仅包括从代码更改开始直到发布的步骤。在本节中，我们将讨论部署术语的所有这些步骤，如下所示:

*   **构建**:在构建阶段，随着所有相应单元测试的通过，服务源被编译，没有任何错误。这个阶段产生构建工件。
*   **持续集成** ( **CI** ):每次开发人员提交任何更改时，CI 都会强制重新构建整个应用程序——应用程序代码被编译，并对其运行一套全面的自动化测试。这种做法源于大型团队中频繁集成代码的问题。基本的想法是保持增量，或者改变软件，小。这提供了软件处于工作状态的信心。即使开发人员的签入破坏了系统，也很容易通过这种方式修复它。
*   **部署**:硬件配置和安装基本操作系统和的正确版本。NET 框架是部署的先决条件。它的下一部分是通过不同的阶段在生产中促进这些构建工件。这两部分的结合称为部署阶段。在大多数单体应用程序中，部署和发布阶段没有区别。
*   **持续部署** ( **CD** ):在 CD 中，每个成功的构建都会部署到生产中。从技术团队的角度来看，光盘更重要。在光盘下，还有一些其他的实践，例如自动化单元测试、标记、版本号的版本化以及变更的可追溯性。通过持续交付，技术团队确保通过各种较低环境推向生产的变更在生产中按预期工作。通常，这些都很小，部署非常快。
*   **连续发货:**连续发货不同于 CD。CD 来自技术团队的观点，而持续交付更侧重于尽早向客户提供部署的代码。为了确保客户获得正确的无缺陷产品，在持续交付中，每一个构建都必须通过所有的质量保证检查。一旦产品通过了令人满意的质量验证，业务涉众就决定何时发布它。
*   **构建和部署管道**:构建和部署管道是通过自动化实现持续交付的一部分。这是一个由步骤组成的工作流，代码通过这些步骤提交到源存储库中。在部署管道的另一端，产生了用于发布的工件。可能组成构建和部署管道的一些步骤如下:
    1.  单元测试
    2.  集成测试
    3.  代码覆盖和静态分析
    4.  回归测试
    5.  部署到临时环境
    6.  负载/压力测试
    7.  部署到发布存储库

*   **发布**:对最终用户可用的业务特性被称为特性的发布。为了发布一个特性或服务，相关的构建工件应该提前部署。通常，功能切换管理功能的发布。如果在生产中未打开功能标志(也称为功能切换)，则称为指定功能的暗释放。

# 微服务部署成功的先决条件

任何建筑风格都有一套相关的模式和实践可以遵循。微服务架构风格也没什么不同。通过采用以下实践，微服务实现更有可能成功:

*   自给自足的团队:亚马逊是 SOA 和微服务架构的先驱，遵循*两个披萨团队*的范式。这意味着一个微服务团队通常不会超过 7-10 名团队成员。这些团队成员将具备所有必要的技能和角色；例如，开发、运营和业务分析师。这样的服务团队处理微服务的开发、运营和管理。
*   CI 和 CD: CI 和 CD 是实现微服务的先决条件。小型自给自足的团队可以频繁地整合他们的工作，这是微服务成功的前兆。这种建筑不像一块巨石那么简单。然而，自动化和定期推动代码升级的能力使团队能够处理复杂性。工具，如**Team Foundation Online Services**(**TFS**)、TeamCity 和 Jenkins，是这一领域相当受欢迎的工具链。
*   作为代码的基础设施:用代码表示硬件和基础设施组件(如网络)的想法是新的。它帮助您使部署环境(如集成、测试和生产)看起来完全相同。这意味着开发人员和测试工程师将能够在较低的环境中轻松重现生产缺陷。使用 CFEngine、Chef、Puppet、Ansible 和 Powershell DSC 等工具，您可以将整个基础架构编写为代码。通过这种范式转换，您还可以将您的基础架构置于版本控制系统之下，并将其作为部署中的工件进行交付。
*   云计算的利用:云计算是采用微服务的一大催化剂。但是对于微服务部署来说，这并不是强制性的。云计算具有近乎无限的规模、弹性和快速配置能力。显而易见，云是微服务的天然盟友。因此，Azure 云的知识和经验将帮助您采用微服务。

# 微服务部署的隔离要求

2012 年，Heroku 平台的联合创始人亚当·威金斯提出了 12 条基本原则。这些原则讨论了从想法到部署定义新的现代 web 应用程序。这套原则现在被称为 *12 因素 app* 。这些原则为发展成微服务架构的新架构风格铺平了道路。12 因素应用程序的原则之一如下:

"Execute the app as one or more stateless processes"  - Adam Wiggins ([https://12factor.net/](https://12factor.net/))

因此，服务本质上将是无状态的(数据库除外，它充当状态存储)。*无共享*原则也适用于所有模式和实践。这只不过是为了实现规模和敏捷性而隔离组件。

在微服务领域，这种隔离原则以下列方式应用:

*   服务团队:将有围绕服务建立的自给自足的团队。实际上，团队将能够做出开发和支持他们所负责的微服务所需的所有决策。
*   源代码控制隔离:每个微服务的源代码存储库将是独立的。它不会共享任何源代码、文件等。在微服务领域跨服务复制一些代码是可以的。
*   构建阶段隔离:为每个微服务构建和部署的管道应该保持隔离。构建和部署管道甚至可以在并行、隔离和部署的服务中运行。因此，应该扩展 CI-CD 工具，以更快的速度支持不同的服务和管道。
*   发布阶段隔离:每个微服务都应该与其他服务隔离发布。生产环境中也可能存在具有不同版本的相同服务。
*   部署阶段隔离:这是隔离最重要的部分。传统的整体部署是通过裸机服务器完成的。随着虚拟化的发展，虚拟服务器已经取代了裸机服务器。

一般来说，单片的标准发布过程如下所示:

![](img/9ce0073e-8ec4-4502-ae59-6e78b1352ddd.png)

考虑到这些隔离级别，微服务构建和部署管道可能如下所示:

![](img/a15dd6e7-0dcb-46cf-ab77-ddff584621ef.png)

# 需要新的部署模式

应用程序的最高隔离级别可以通过添加新的物理机或裸机服务器来实现，这样就有了一个拥有自己的操作系统来管理所有系统资源的服务器。这在传统应用程序中是常见的，但在现代应用程序中并不实用。现代应用是庞大的系统。这些系统的一些例子是亚马逊、网飞和耐克，甚至是传统的金融银行，如荷兰国际集团。这些系统托管在数万台服务器上。这些类型的现代应用程序需要超可扩展性来服务于数百万用户。对于微服务架构来说，仅仅为了在其上运行一个小服务而设置一个新服务器是没有任何意义的。

随着新的 CPU 架构突破，出现的选项之一是虚拟机。虚拟机通过虚拟机管理程序技术抽象出操作系统的所有硬件交互。虚拟机管理程序使我们能够在一台物理机上运行多台机器或服务器。需要注意的一个重要点是，所有虚拟机都从物理主机资源中获得自己的一部分隔离系统资源。

这仍然是运行应用程序的良好隔离环境。虚拟化带来了为整个应用程序提升服务器的基本原理。在这样做的同时，它保持了组件的隔离；这有助于我们利用数据中心的备用计算机资源。它提高了我们数据中心的效率，同时满足了应用程序的合理隔离需求。

然而，虚拟化本身无法支持微服务的某些需求。在 12 因素原则下，亚当也谈到了这一点:

"The twelve-factor app’s processes are disposable, meaning they can be started or stopped at a moment’s notice. This facilitates fast elastic scaling, rapid deployment of code or config changes, and robustness of production deploys." - Adam Wiggins ([https://12factor.net/](https://12factor.net/))

这个原则对于微服务架构风格很重要。因此，对于微服务，我们必须确保服务启动得更快。在这种情况下，让我们假设每个虚拟机有一个服务。如果我们想旋转这个服务，它首先需要旋转虚拟机；但是，虚拟机的启动时间很长。另一件事是，对于这样的应用程序，我们正在谈论大量集群部署。所以服务肯定会以集群的形式分布。

这也意味着虚拟机可能需要在集群中的一个节点上启动并启动。这也是虚拟机启动时间的问题。这并没有带来我们所期望的微服务效率。

现在，剩下的唯一选择是使用操作系统进程模型，它会带来更快的启动时间。过程编程模型早已广为人知，但即使是过程也是有代价的。它们没有很好地隔离，共享系统资源以及操作系统的内核。

对于微服务，我们需要更好的隔离部署模型和新的部署范式。答案是这样的:集装箱技术的创新。一个很好的考虑因素是容器技术位于虚拟化和操作系统的流程模型之间。

# 容器

容器技术对于 Linux 世界来说并不陌生。容器基于 Linux 的 LXC 技术。在这一节中，让我们看看容器在微服务的情况下有多重要。

# 什么是容器？

容器是完整文件系统中的一个软件。它包含运行代码、运行时、系统工具和系统库所需的一切——任何可以安装在服务器上的东西。这保证了软件将始终以相同的方式运行，而不管其环境如何。容器与同一主机上的其他容器共享其主机操作系统和内核。围绕集装箱的技术并不新鲜。长期以来，它一直是 Linux 生态系统的一部分。由于最近围绕它的基于微服务的讨论，容器技术再次成为人们关注的焦点。此外，这也是谷歌、亚马逊和网飞运行的技术。

# 容器对虚拟机的适用性

让我们理解容器和虚拟机之间的区别——在表面上，两者都是实现隔离和虚拟化的工具。

从下图中可以明显看出虚拟机和容器之间的架构差异:

![](img/573dff2c-d1dd-458f-a502-0ca9441871e5.png)

通过查看虚拟机内部，我们可以看到有一个主机操作系统和一个内核，以及在内核之上的虚拟机管理程序层。托管应用程序必须引入自己的操作系统和环境。但是在容器中，容器化技术层作为一个单独的层，在不同的应用程序中共享。这消除了对客户操作系统的需求。因此，容器中的应用程序占用空间更小，隔离级别更高。鼓励您使用容器进行微服务部署的另一个方面是，与部署在虚拟机上的相同应用程序相比，我们可以在同一台物理机上打包更多的应用程序。这有助于我们实现更大的规模经济优势，并提供虚拟机优势的比较。

容器还有一点需要注意，它们也可以在虚拟机上运行。因此，在物理服务器上安装虚拟机是可以的。该虚拟机充当许多容器的主机。

# 运营团队心态的转变

微软的比尔·贝克提出了宠物和牛的类比，并将其应用于数据中心的服务器。好吧，老实说，我们关心我们的宠物。我们爱他们，向他们表达爱意，我们也给他们取名。我们想到他们的卫生；如果它们生病了，我们会带它们去看兽医。我们这样照顾我们的牛吗？当然，我们没有；这是因为我们不太关心牛。

同样的类比也适用于服务器和容器。在 DevOps 之前，服务器管理员关心服务器。他们曾经命名那些服务器机器，并且也有专门的维护停机时间等等。有了 DevOps 实践，比如代码和容器化这样的基础设施，容器就可以被当作牛来对待。作为运营团队，我们不需要关心它们，因为集装箱的寿命很短。它们可以在集群中快速启动，也可以快速拆除。当您处理容器时，请始终记住这个类比。就日常操作而言，期望容器的旋转和拆卸是正常的做法。

这种类比改变了对微服务部署及其如何支持容器化的看法。

# 容器是新的二进制文件

作为. NET 开发人员，这是一个新的现实:使用微服务。容器是新的二进制文件。使用 Visual Studio，我们可以编译。NET 程序并编译后，Visual Studio 生成。NET 程序集，即 dll 或 exe。我们将编译器发出的这组相关联的 dll 和 exe 部署到服务器上。

"Containers are new binaries of deployment" - Steve Lasker, Principal Program Manager at Microsoft

简而言之，我们的部署单元是以集合的形式。不再是了！我们还有。NET 程序生成 exe 和 dll，但是我们的部署单元在微服务世界中发生了变化。现在是集装箱了。我们仍将把程序编译成程序集。这些组件将被推到集装箱中，准备装运。

当我们在本章的下一节中查看代码演练时，您将理解这一点。我们作为。NET 开发人员有能力(我可以说是必要的)运送容器。除此之外，容器部署的另一个优点是它消除了不同操作系统甚至不同语言和运行时之间的障碍。

# 它在你的机器上工作吗？让我们运送你的机器！

通常，我们从开发者那里听到很多这样的话:*嗯，它在我的机器上工作！*这通常发生在生产中存在不可重现的缺陷时。因为容器是不可变的和可组合的，所以很有可能消除开发和生产环境之间的配置阻抗。

# 介绍 Docker

docker(www.docker.com)一直是推广应用程序容器化的主要力量。Docker 之于容器就像谷歌之于搜索引擎。有时，人们甚至使用容器和 Docker 作为同义词。微软已经与 Docker 建立了合作伙伴关系，并积极为开源的 Docker 平台和工具做出贡献。这使得 Docker 对我们来说非常重要。NET 开发人员。

Docker 是一个非常重要的话题，对任何严肃的人来说都是非常重要的。NET 开发人员。然而，由于时间和范围的限制，我们将在这里仅仅触及 Docker 生态系统的表面。我们强烈建议您通读帕克特出版公司提供的 Docker 书籍。

If you want to safely try and learn Docker without even installing it on your machine, you can do so with [https://KataCoda.com](https://www.katacoda.com/).

现在让我们关注 Docker 平台的一些术语和工具。这对于我们的下一部分至关重要:

*   Docker 映像:Docker *映像*是一个只读模板，包含创建 Docker 容器的指令。Docker 映像由单独的文件系统、关联的库等组成。在这里，图像始终是只读的，并且可以运行完全相同的抽象、底层、主机差异。Docker 图像可以由一层叠加在另一层上组成。Docker 图像的这种可组合性可以与分层蛋糕的类比进行比较。跨不同容器使用的 Docker 映像可以重用。这也有助于减少使用相同基础映像的应用程序的部署占用空间。
*   Docker 注册表:Docker 注册表是一个图像库。注册表可以是公共的，也可以是私有的。此外，它可以与 Docker 守护程序或 Docker 客户端位于同一个服务器上，也可以位于完全独立的服务器上。
*   这是一个公共注册表，它存储图像。位于[http://hub.docker.com](http://hub.docker.com/)。
*   Dockerfile: Dockerfile 是一个构建或脚本文件，包含构建 Docker 映像的指令。Dockerfile 中可以记录多个步骤，从获取基础映像开始。
*   停靠容器:停靠容器是停靠图像的不可执行实例。
*   Docker compose: Docker compose 允许您在一个文件中定义应用程序的组件——它们的容器、配置、链接和卷。然后，一个命令就可以设置一切并启动应用程序。它是应用程序的架构/依赖关系图。
*   Docker swarm: Swarm 是 Docker 服务，容器节点通过它一起工作。它运行定义数量的副本任务实例，副本任务本身就是 Docker 映像。

让我们来看看 Docker 生态系统的各个组件；让我们尝试理解 Docker 工作流在软件开发生命周期中有意义的方式之一。

# 带有 Docker 概述的微服务部署

为了支持这个工作流，我们需要一个配置项工具和一个配置管理工具。为了便于说明，我们将**Visual Studio Team Services**(**VSTS**)构建服务作为 CI 和 VSTS 发布管理进行持续交付。对于任何其他工具或部署模式，工作流将保持不变。以下是 Docker 的微服务部署风格之一:

1.  代码被签入 VSTS 存储库。如果这是项目的第一次签入，它将与项目的 Dockerfile 一起完成。
2.  前面的签入触发 VSTS 从源代码构建服务并运行单元/集成测试。
3.  如果测试成功，VSTS 将构建一个 Docker 映像，并将其推送到 Docker 注册表*。VSTS 发布服务将映像部署到 Azure 容器服务中。*
**   如果质量保证测试也通过了，VSTS 被用来促进容器的部署并开始生产。*

 *下图详细描述了这些步骤:

![](img/d7114146-d0cb-4056-9907-dc417ff590fe.png)

Note that the usual .NET CI-CD tools, such as TeamCity and Octopus Deploy (capabilities are in alpha stage), have features to produce a Docker container as a build artifact and deploy it to production.

# 使用 Docker 的微服务部署示例

现在，我们已经掌握了走向编码并亲眼看看事情如何运作所需的所有要素。我们在这里以产品目录服务为例，将其部署为 Docker 容器。运行附带的源代码后，您应该能够在 Docker 容器中成功运行产品目录服务。

# 在您的机器上设置 Docker

本教程不需要 Docker 的任何现有知识，大约需要 20 或 30 分钟才能完成。

# 先决条件

您需要执行以下操作:

1.  安装微软 Visual Studio 2017 更新 3([https://www . visualstudio . com/downloads/downloads-Visual-Studio-vs](https://www.visualstudio.com/downloads/download-visual-studio-vs))
2.  安装。NET Core 2.0([https://www.microsoft.com/net/download/core](https://www.microsoft.com/net/download/core)[)](https://go.microsoft.com/fwlink/?LinkID=827546)
3.  为 Windows 安装 Docker 以在本地运行您的 Docker 容器([https://www.docker.com/products/docker#/windows](https://www.docker.com/products/docker#/windows))

We are using Docker Community Edition for Windows to demonstrate the example.

4.  安装后，您的系统需要重新启动才能完成安装。
5.  重新启动后，如果系统上未启用 Hyper-V 功能，Windows Docker 将提示您启用该功能。单击“确定”在您的系统上启用 Hyper-V 功能(需要重新启动系统)。参考以下截图:

![](img/2c544f4d-910c-43c9-8c82-55a51c290387.png)

6.  安装 Windows Docker 后，右键单击系统托盘中的 Docker 图标，然后单击设置并选择共享驱动器:

![](img/15af9b53-4213-451e-b3ae-e71b91c71d02.png)

# 创建 ASP.NET 核心网络应用程序

以下是开始的简单步骤:

1.  通过导航到文件|新项目|创建新项目。NET Core |选择 ASP.NET 核心 Web 应用，参考以下截图:

![](img/27b5d3b3-d1b6-4c2d-a0e1-31752a7c10a4.png)

2.  在新 ASP.NET 核心网络应用程序窗口中，选择。NET 核心和 ASP.NET 核心 2.0。
3.  从可用模板中选择网络应用程序(模型-视图-控制器)。
4.  选中启用 Docker 支持。
5.  当我们为 Windows 演示时，请选择操作系统作为 Windows(如果您没有安装前一节中提到的 Docker，这里您需要为 Windows 安装 Docker)。
6.  点击确定继续，参见下面的截图:

![](img/f53a167d-af7a-4ec0-ae9e-cfca32f11edf.png)

前面的步骤将在 Docker 的支持下创建`FlixOne.BookStore.ProductService`项目。下面是显示我们项目结构的截图:

![](img/c34b34a9-ebc3-4241-97c6-21e07ca4d291.png)

以下文件被添加到项目中:

*   `Dockerfile`:ASP.NET 核心应用的 Dockerfile 基于微软/aspnetcore 映像([https://hub.docker.com/r/microsoft/aspnetcore/](https://hub.docker.com/r/microsoft/aspnetcore/))。这张图片包括 ASP.NET 核心 NuGet 包，这已经预先安装，提高了启动性能。构建 ASP.NET 核心应用程序时，Dockerfile FROM 指令(命令)指向 Docker 中枢上最新的微软/dotnet 映像([https://hub.docker.com/r/microsoft/dotnet/](https://hub.docker.com/r/microsoft/dotnet/))。以下是模板提供的默认代码片段:

```cs
FROM microsoft/aspnetcore:2.0
ARG source
WORKDIR /app
EXPOSE 80
COPY ${source:-obj/Docker/publish} .
ENTRYPOINT ["dotnet", "FlixOne.BookStore.ProductService.dll"]
```

前面的代码基本上是一组指令，这些指令如下:

`FROM`告诉 Docker 要在现有图像上拉基础图像，调用`microsoft/aspnetcore:2.0`。这个映像已经包含了在 Linux 上运行 ASP.NET 内核的所有依赖项，所以我们不必设置它。

`COPY`和`WORKDIR`将当前目录的内容复制到被调用/app 容器内的新目录中，并将其设置到工作目录中，以供后续指令使用。

`EXPOSE`告诉 Docker 在容器的端口 80 上公开产品目录服务。

`ENTRYPOINT`指定容器启动时要执行的命令。在这种情况下，它是. NET

*   `Docker-compose.yml`:这是基本的 Compose 文件，用于定义要构建和运行的图像集合，使用`Docker-compose`构建/运行。
*   `Docker-compose.dev.debug.yml`:这是一个额外的编写文件，用于在您的配置设置为调试时进行迭代更改。Visual Studio 将调用`-f docker-compose.yml`和`-f docker-compose.dev.debug.yml`将其合并。Visual Studio 开发工具使用此编写文件。
*   `Docker-compose.dev.release.yml`:这是一个额外的编写文件，用于调试您的发布定义。它将独立加载调试器，因此不会更改生产映像的内容。

`docker-compose.yml`文件包含项目运行时创建的图像的名称。

我们现在拥有了在 Docker 容器中运行/启动服务所需的一切。在我们继续之前，请参考[第 2 章](02.html)、*实现微服务*，并添加完整的代码(即控制器、存储库等)，这样项目结构看起来像下面的截图:

![](img/ade370fb-7585-4a16-936b-d23a1afa3f33.png)

现在你所要做的就是按下 *F5* 并在容器中启动你的服务。这是将您的服务放入容器中最简单易行的方法。一旦您的微服务被容器化，您就可以使用 Visual Studio 团队服务和 Azure 容器服务将您的容器部署到 Azure 云([https://docs . Microsoft . com/en-us/Azure/container-service/dcos-swarm/container-service-deployment](https://docs.microsoft.com/en-us/azure/container-service/dcos-swarm/container-service-deployment))。

# 摘要

微服务部署对我们来说是一次激动人心的旅程。为了成功交付微服务，应该遵循部署最佳实践。甚至在我们谈论使用自动化工具进行部署之前，我们需要专注于实现微服务的隔离需求。通过成功的微服务部署实践，我们可以快速交付业务变化。不同的隔离，从自给自足的团队到持续交付的需求，提供了规模和敏捷性，这是微服务的基本承诺。容器化是迄今为止我们拥有的最重要的创新技术之一，我们必须利用它来部署微服务。将 Azure 云与 Docker 相结合将有助于我们提供微服务所期望的规模和隔离。借助 Docker，我们可以轻松实现更高的应用密度，这意味着我们的云基础架构成本降低。我们还看到了使用针对 Windows 的 Visual Studio 和 Docker 工具启动这些部署是多么容易。

在下一章中，我们将研究微服务安全性。我们将讨论用于身份验证的 Azure 活动目录，如何利用 OAuth 2.0，以及如何使用 Azure API Management 保护 API 网关。*