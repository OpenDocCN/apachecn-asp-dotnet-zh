# 保护微服务

安全性是 web 应用最重要的交叉问题之一。不幸的是，如今知名网站的数据泄露似乎司空见惯。考虑到这一点，信息和应用安全对于 web 应用来说变得至关重要。出于同样的原因，安全应用不应再是事后的想法。安全是组织中每个人的责任。

与微服务相比，单片应用的表面积更小，然而，微服务本质上是分布式系统。同样，原则上，微服务是相互隔离的；因此，与单片应用相比，实现良好的微服务更加安全。与微服务相比，单块有不同的攻击媒介。微服务架构风格迫使我们在安全的背景下进行不同的思考。然而，让我提前告诉你，微服务安全是一个很难理解和实现的复杂领域。

在我们深入研究微服务安全之前，让我们了解一下我们的方法。我们将更加关注身份验证和授权(在本章中统称为 **auth** )如何工作以及中可用的选项。NET 生态系统。

我们将探索 Azure 应用编程接口管理及其作为应用编程接口网关的适用性。基于. NET 的微服务环境；我们还将看到 Azure API 管理如何通过其安全功能帮助我们保护微服务。然后，我们将简要介绍具有深度防御微服务安全机制的不同外围方面。我们还将讨论以下主题:

*   为什么表单身份验证和旧技术还不够？
*   身份验证和可用选项，包括 OpenID 和 Azure 活动目录
*   引入 OAuth 2.0
*   引入 Azure 应用编程接口管理作为应用编程接口网关
*   使用 Azure 应用编程接口管理安全性
*   服务间通信安全方法
*   集装箱安全和其他外围安全方面

# 单片应用的安全性

为了理解微服务安全性，让我们回顾一下我们过去是如何保护的。NET 单片应用。这将帮助我们更好地理解为什么微服务的授权机制需要不同。

保护应用的关键机制一直是 auth。认证验证用户的*身份*。授权管理用户可以访问或不能访问的内容，也称为*权限*。加密，嗯，这是帮助您在客户端和服务器之间传递数据时保护数据的机制。不过，我们不会过多讨论加密，只要确保通过网络传输的数据在任何地方都是加密的。这可以通过使用《HTTPS 议定书》来实现。

下图描述了中典型身份验证机制的流程。NET 单片:

![](img/32f49f3e-6ee8-46b2-bab1-522df1864c8b.png)

在上图中，我们可以看到用户通常通过网络浏览器输入他或她的用户名和密码。然后，这个请求到达负责授权的 web 应用中的某个薄层。该层或组件连接到用户凭据存储，在. NET 应用的情况下，通常是一个 SQL 服务器。身份验证层根据存储在凭据存储中的用户名和密码验证用户提供的凭据。

一旦验证了会话的用户凭据，就会在浏览器中创建会话 cookie。除非用户拥有有效的会话 cookie，否则他无法访问该应用。通常，每个请求都会发送一个会话 cookie。在这些类型的单片应用中，模块可以自由地相互交互，因为它们在同一个进程中并且具有内存访问。这意味着信任隐含在这些应用模块中，因此它们在相互对话时不需要单独的请求验证和确认。

# 微服务的安全性

现在让我们看看微服务的例子。本质上，微服务是分布式系统。没有一个应用实例；相反，有几个不同的应用相互协调以产生所需的输出。

# 为什么传统的？NET 身份验证机制工作正常吗？

微服务安全的一种可能方法可能是这样的:我们模仿与单块中授权层相同的行为。这可以描述如下:

![](img/9605f3e4-dac1-41d9-ac5a-f72ffbd955ae.png)

在这种方法中，我们分发了身份验证层，并将其提供给所有微服务。因为每个都是不同的应用，所以它需要自己的身份验证机制。这本质上意味着每个微服务的用户凭据存储也是不同的。这引发了很多问题，比如我们如何在所有服务之间保持身份验证同步？我们如何验证服务间通信，还是跳过它？我们对这些问题没有满意的答案。因此，这种方法没有意义，只会增加复杂性。用这种方法，我们甚至不能确定它在现实世界中是否可行。

对于现代应用，我们还需要考虑一个因素。在微服务领域，我们需要支持原生移动应用和其他非标准外形设备以及物联网应用。随着本地移动应用的大量增加，微服务架构也需要支持这些客户端和微服务之间的安全通信。这不同于传统的基于网络浏览器的用户界面。在移动平台上，网络浏览器不是任何本地移动应用的一部分。这意味着基于 cookie 或基于会话的身份验证是不可能的。因此微服务需要支持客户端应用之间的这种互操作性。这从来不是一个问题。NET 单片应用。

在传统身份验证的情况下，浏览器负责根据每个请求发送 cookie。但是我们没有将浏览器用于本地移动应用。事实上，我们既没有使用 ASPX 页面，也没有使用表单的身份验证模块。对于 iOS 客户端或安卓系统来说，这完全是两码事。此外，我们还试图限制对我们的应用编程接口的未经授权的访问。在前面的例子中，我们将保护客户端，无论是 MVC 应用还是 Windows 手机应用，而不是微服务。此外，所有这些移动客户端设备都不是信任子系统的一部分。对于每个请求，我们不能相信移动用户确实是所有者；通信信道也不安全。因此，来自他们的任何请求都是不可信的。

但是除了这些问题，我们还有另一个更概念性的问题。为什么应用应该负责验证用户和授权？这不应该分开吗？

对此的另一个解决方案是使用 SAML 协议，但同样，这是基于 SOAP 和 XML 的，因此不太适合微服务。SAML 的实现复杂度也很高。

因此，从前面的讨论中可以明显看出，我们需要一个基于令牌的解决方案。微服务授权的解决方案以开放身份连接和开放身份验证 2.0 的形式出现。OpenID Connect 是身份验证的标准，OAuth 2.0 是授权的规范。然而，这种授权是自然委托的。

我们将在后面的章节中详细讨论这一点。但在此之前，让我们绕道看看 JSON 网络令牌，看看它们为什么在微服务安全方面如此重要。

# JSON Web 令牌

**JSON 网络代币** ( **JWT** )发音为 *JOT* 。这是一个定义良好的 JSON 模式或格式，用于描述数据交换过程中涉及的令牌。JWTs 在 *RFC 7519* 中有描述。

JWTs 既没有绑定到 OpenID Connect，也没有绑定到 OAuth 2.0。这意味着它们可以独立使用，无论 OAuth 2.0 还是 OpenID Connect。OpenID Connect 要求在此过程中交换的所有令牌都使用 JWT。在 OAuth 2.0 中，JWTs 的使用不是强制性的，更像是一种实现格式。此外。NET 框架内置了对 JWT 的支持。

基于 JWT 的安全令牌的目的是产生一个数据结构，该结构包含关于发行者和接收者的信息以及发送者身份的描述。因此，令牌应该通过网络进行保护，这样就不会被篡改。为此，使用对称或非对称密钥对令牌进行签名。这意味着当接收者信任令牌的发行者时，它也可以信任令牌内部的信息。

这里有一个 JWT 的例子:

```cs
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

这是 JWT 的编码形式。如果我们看到解码形式的相同令牌，它有三个组成部分:报头、有效载荷和签名；它们都用句点(.)隔开。).前面的示例令牌可以解码如下:

```cs
Header: {"alg": "HS256", "type": "JWT"}
Payload: {"sub": "1234567890","name": "John Doe","admin": true}
Signature:HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret)
```

NET v.4.5.1 及更高版本内置了对生成和使用 JWTs 的支持。您可以在任何位置安装 JWT 支持。NET 应用，使用带有以下命令的包管理器控制台:

```cs
Install-Package System.IdentityModel.Tokens.Jwt
```

Visit [https://jwt.io/](https://jwt.io/), where you can view and decode JWTs very easily. Moreover, you can add it as part of the Chrome debugger as well, which is quite handy.

# 什么是 OAuth 2.0？

好吧，你可能不知道 OAuth 2.0 是什么，但你肯定已经在几个网站上使用过了。如今，许多网站允许你使用脸书、推特或谷歌账户的用户名和密码登录。去你喜欢的网站，例如[www.stackoverflow.com](http://www.stackoverflow.com)登录页面。例如，有一个登录按钮说你可以用你的谷歌账户登录。当你点击谷歌按钮时，它会带你进入谷歌的登录页面，并带有一些提到的权限。在这里，您提供您的谷歌用户名和密码，并点击允许按钮，以授予您最喜欢的网站的权限。然后，谷歌将您重定向到堆栈溢出，您以堆栈溢出中的适当权限登录。这仅仅是 OAuth 2.0 和 OpenID Connect 的最终用户体验。

OAuth 2.0 可以最好地描述为一系列由规范转向授权的框架。 *RFC 6749* 对 OAuth 的定义如下:

"The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf."

OAuth 2.0 处理 web 上、原生移动应用中以及所有无头服务器应用中的授权(在我们的上下文中，这些只不过是微服务实例)。你一定想知道为什么我们要先讨论授权而不是身份验证。原因是 OAuth 2.0 是一个委托授权框架。这意味着，为了完成授权流程，它依赖于身份验证机制。

现在让我们看看与之相关的一些术语。

OAuth 2.0 角色描述了授权过程中涉及的各方:

*   资源:受到保护而不被意外访问和使用的实体。在我们的例子中，这只不过是一个微服务。
*   资源所有者:资源所有者是拥有指定资源的个人或实体。当一个人拥有资源时，他或她就是最终用户。
*   客户端:客户端是用来指代各种客户端应用的术语。这是指任何试图访问受保护资源的应用。在微服务的上下文中，涉及的应用是单页应用、web 用户界面客户端和本地移动应用，甚至是试图访问下游另一个微服务的微服务。
*   授权服务器:这是托管安全令牌服务的服务器，在成功验证资源所有者并从资源所有者或代表他们获得权限后，向客户端颁发令牌。

您可能已经注意到，OAuth 确实区分了最终用户和最终用户使用的应用。这有点奇怪，但很有道理，因为它也被普遍认为是说，*我授权这个应用代表我执行这些操作*。

下图描述了这些角色如何在 OAuth 框架的一般授权流程中相互作用:

![](img/e58404a3-3107-4236-ba49-b9e8dda72c70.png)

在*步骤 6* 中，如上图所示，客户端将授权许可传递给授权服务器。这一步并不像看起来那么简单。授权有不同的类型。授权类型代表了在 OAuth 2.0 中获取访问令牌的四种不同的可能用例。如果您选择了错误的授权类型，您可能会危及安全性:

*   授权代码:这是服务器端 web 应用使用的典型 OAuth 授权，您可以在 ASP.NET 应用中使用。
*   隐式:向服务器进行身份验证会向浏览器返回一个访问令牌，该令牌可用于访问资源。这对于通信不能保密的单页应用很有用。
*   资源所有者密码凭据:这要求用户在应用中直接输入他们的用户名和密码。当您正在开发第一方应用以使用自己的服务器进行身份验证时，这非常有用。例如，移动应用可能使用资源所有者授权向您自己的服务器进行身份验证。
*   客户端凭据:这通常在客户端代表自己行事(客户端也是资源所有者)或基于授权服务器预先安排的授权请求访问受保护资源时使用。

# 什么是 OpenID Connect？

OpenID Connect 1.0 是 OAuth 2.0 协议之上的一个简单的身份层。OpenID Connect 是关于身份验证的。它允许客户端根据授权服务器执行的身份验证来验证最终用户。它还用于以可互操作和类似 REST 的方式获取终端用户的基本配置文件信息。

因此，OpenID Connect 允许所有类型的客户端——基于网络的、移动的和 JavaScript——请求和接收关于经过身份验证的会话和最终用户的信息。我们知道 OAuth 2.0 定义了访问令牌。好吧，OpenID Connect 定义了一个标准化的身份令牌(通常称为 **ID 令牌**)。身份令牌被发送到应用，以便应用可以验证用户是谁。它定义了一个端点来获取该用户的身份信息，例如他们的姓名或电子邮件地址。这是用户信息端点。

它建立在 OAuth 2.0 之上，所以流程是相同的。它可以与授权码授权和隐式授权一起使用。客户端凭证授权是不可能的，因为客户端凭证授权是用于服务器到服务器的通信。

这个过程中没有最终用户，因此也没有最终用户身份。同样，对于资源所有者的使用路径或流程来说，这也没有意义。这是怎么回事？我们将从**安全令牌服务** ( **STS** )请求一个额外的 ID 令牌来实现 OpenID Connect 规范，而不是只请求一个访问令牌。客户端会收到一个标识令牌，通常还会收到一个访问令牌。为了获得经过身份验证的用户的更多信息，客户端然后可以使用访问令牌向用户信息端点发送请求；然后，该用户信息端点将返回关于新用户的声明。

OpenID 支持授权代码流和隐式流。它还增加了一些附加协议，即发现和动态注册。

# 活动目录

OAuth 2.0 和 OpenID Connect 1.0 规范有多个提供者。**天青活动目录** ( **天青 AD** )就是其中之一。Azure AD 为组织提供面向云应用的企业级身份管理。Azure AD 集成将为您的用户提供简化的登录体验，并帮助您的应用符合 it 政策。Azure AD 提供了高级安全功能，例如多因素身份验证，并且可以随着应用的增长而很好地扩展。它用于所有微软 Azure 云产品，包括 Office 365，每天处理超过 10 亿次登录。

传统的一个更有趣的方面。NET 环境是他们可以很好地将他们的组织 Windows Server 活动目录与 Azure AD 集成在一起。这可以通过 Azure 广告同步工具或新的直通身份验证功能来实现。因此，组织的信息技术合规性仍将得到管理。

# 使用 OpenID Connect、OAuth 2.0 和 Azure AD 的微服务身份验证示例

现在我们已经具备了开始编码的所有先决知识。让我们尝试构建一个`ToDoList`应用。我们将保护`TodoListService`，它代表了我们的微服务之一。在解决方案中，`ToDoList`微服务由`TodoListService`项目表示，`ToDoListWebApp`代表服务器端 web 应用。如果打开本章提供的名为`OpenIdOAuthAzureAD.sln`的 Visual Studio 解决方案，会更容易理解。此示例使用客户端凭据授予。

请注意，由于 Azure 门户和相应的 Azure 服务用户界面的不断变化的性质，建议您使用 Azure 服务管理应用编程接口，并自动执行一些即将到来的注册任务。然而，出于学习的目的，主要是为了鼓励对 Azure 不熟悉或可能第一次尝试 Azure 广告的开发人员，我们将遵循 Azure 门户用户界面。

以下是先决条件:

*   Visual Studio 2017 更新 3
*   Azure 订阅(如果您没有这个，您可以使用免费试用帐户进行演示)
*   Azure AD 租户(单租户):您也可以使用 Azure 帐户自己的默认目录，该目录应该不同于 Microsoft 组织的目录

# 向 Azure AD 租户注册 TodoListService 和 TodoListWebApp

现在我们来看看如何注册`TodoListService`。

这一步，我们将用 Azure AD 租户添加`TodoListService`。为此，请登录 Azure 管理门户，然后执行以下操作:

1.  点击应用注册。点击添加按钮。它将打开创建窗格，如下所示:

![](img/64a8579c-88d4-4915-ba87-4fa8380a541c.png)

2.  提供前面截图中显示的所有强制详细信息，并单击“创建”窗格底部的“创建”按钮。当我们提供一个登录网址时，请确保您正在为您的应用提供它。在我们的例子中，`TodoListService`是一个微服务，所以我们不会有一个特殊的登录网址。因此，我们必须提供默认的网址或者仅仅是微服务的主机名。这里我们将从我们的机器上运行服务，所以本地主机网址就足够了。右键点击`TodoListService`项目下的项目网址，导航到网站，即可找到登录网址，如下图所示:

![](img/c17fcbdb-a832-45a4-a51a-0be9d55c28c7.png)

`/`

3.  如果您使用微软 Azure 应用服务计划部署您的服务，您将获得一个类似于`https://todolistservice-xyz.azurewebsites.net/`的网址。如果您在 Azure 上部署该服务，您可以稍后更改登录网址。
4.  一旦你点击了创建按钮，Azure 会将应用添加到你的 Azure AD 租户中。然而，要完成 TodoListService 的注册，还有一些细节需要完成。因此，请导航至应用注册|至服务|属性。您会注意到还有一些额外的属性，例如现在已经提供的应用标识网址。

5.  对于 App ID URL，输入 [`https://[Your_Tenant_Name]/TodoListService`](https://%5BYour_Tenant_Name%5D/TodoListService) ，用您的 Azure AD 租户名称替换`[Your_Tenant_Name]`。单击确定完成注册。最终配置应该如下所示:

![](img/084b7590-c707-4eb9-a75c-898ae12cf8b9.png)

现在我们来看 TodoListWebApp 的注册:

1.  首先，我们注册到 doListWebApp。这是必要的，因为我们将使用 OpenID Connect 来连接到这个基于浏览器的网络应用。所以我们需要在最终用户，也就是我们和 TodoListWebApp 之间建立信任。
2.  点击应用注册。点击添加按钮。它将打开创建窗格，如下图所示。填写登录网址为`https://localhost:44322/`。

3.  同样，在 TodoListService 注册中，一旦我们创建了 web 应用，我们将能够查看大多数附加属性。因此，最终的属性配置将如下所示:

![](img/4a21493b-5c13-4e8c-b04b-cb687e1f607b.png)

4.  这里需要注意的一个设置是注销网址:我们将其设置为`https://localhost:44322/Account/EndSession`。
    这是因为结束会话后，Azure AD 会将用户重定向到这个 URL。对于应用标识网址，输入`https://[Your_AD_Tenant_Name]/TodoListWebApp`，用您的 Azure 广告租户的名称替换[ `Your_AD_Tenant_Name` ]。单击确定完成注册。

5.  现在我们需要在 TodoListWebApp 之间设置权限，这样它就可以调用我们的微服务:TodoListService。因此，再次导航至应用注册|至许可|所需权限，然后单击添加。现在点击 1 选择一个应用编程接口。该导航显示在下面的屏幕截图中。您需要键入 ToDoListService，它才会显示在应用编程接口窗格中:

![](img/46044531-310c-4a25-aa0d-29b222d2bf12.png)

6.  现在，您将能够查看“启用访问”窗格，在该窗格中，您必须在“委托权限”下勾选“访问授权服务权限”，在“添加应用编程接口访问”窗格中勾选“完成”。这将保存权限。

# TodoListWebApp 的 AppKey 的生成

注册的另一个重要步骤是添加`client_secret`，这是在 Azure AD 和 TodoListWebApp 之间建立信任所必需的。这个`client_secret`只生成一次，在 web 应用中配置。要生成此密钥，请导航到应用注册|到策略向导|密钥。然后，添加描述为`AppKey`并点击保存。保存密钥后，Azure 会自动生成密钥的值，并显示在描述旁边。该键仅显示一次，因此您必须立即复制并保存它以备后用。在这种情况下，我们将把这个密钥保存在 TodoListWebApp 的`web.config`文件中。

存储的密钥将显示在 Azure 门户上，如下所示:

![](img/a983ea10-4845-4d3d-809f-d39af7965390.png)

`client_Secret`

`web.config`

[https://azure.microsoft.com/en-us/services/key-vault/](https://azure.microsoft.com/en-us/services/key-vault/)

# 配置 Visual Studio 解决方案项目

首先，我们看一下如何用`TodoListService`项目配置这个。

打开`web.config`文件，更换以下按键:

1.  搜索`ida:Tenant`键。用您的 AD 租户名称替换它的值，例如，`contoso.onmicrosoft.com`。这也将是任何应用的应用标识网址的一部分。
2.  更换`ida:Audience `键。将其值替换为`https://[Your_AD_Tenant_Name]/TodoListService`。
    将`[Your_AD_Tenant_Name]`替换为您的 Azure AD 租户的名称。

现在让我们看看如何用`TodoListWebApp`项目配置这个。

打开`web.config`文件，用提供的值查找并替换以下键:

1.  将`todo:TodoListResourceid`替换为`https://[Your_Tenant_Name]/TodoListService`。
2.  将`todo:TodoListBaseAddress`替换为`https://localhost:44321/`。
3.  将`ida:ClientId`替换为 ToDoListWebApp 的应用标识。您可以通过导航到应用注册| TodoListWebApp 来获取它。
4.  将`ida:AppKey`替换为我们在注册 TodoListWebApp 过程的第 2 步中生成的`client_secret`。如果您没有注意到这个键，您需要删除以前的键并生成一个新的键。
5.  将`ida:Tenant`替换为您的 AD 租户名称，例如`contoso.onmicrosoft.com`。
6.  将`ida:RedirectUri`替换为您希望应用在用户注销 TodoListWebApp 时重定向到的 URL。在我们的例子中，默认值是`https://localhost:44322/`，因为我们希望用户导航到应用的主页。

# 在 IIS Express 上生成客户端证书

现在`TodoListService`和`TodoListWebApp`将通过一个安全的通道进行对话。要建立安全通道，`ToDoListWebApp`需要信任客户端证书。这两种服务都托管在同一台计算机上，并在 IIS Express 上运行。

要将您的计算机配置为信任 IIS Express SSL 证书，请以管理员身份打开 PowerShell 命令窗口。查询您的个人证书库，找到`CN=localhost`的证书指纹:

```cs
PS C:windowssystem32> dir Cert:LocalMachineMy
Directory: Microsoft.PowerShell.SecurityCertificate::LocalMachineMy
Thumbprint Subject
---------- -------
C24798908DA71693C1053F42A462327543B38042 CN=localhost
```

接下来，将证书添加到受信任的根存储:

```cs
PS C:windowssystem32> $cert = (get-item cert:LocalMachineMyC24798908DA71693C1053F42A462327543B38042)
PS C:windowssystem32> $store = (get-item cert:LocalmachineRoot)
PS C:windowssystem32> $store.Open("ReadWrite")
PS C:windowssystem32> $store.Add($cert)
PS C:windowssystem32> $store.Close()
```

前面的一组指令将向本地计算机的证书存储中添加一个客户端证书。

# 运行这两个应用

我们已经完成了所有那些繁琐的配置屏幕和按键更换。兴奋吗？但是在你点击 *F5* 之前，先设置`ToDoListService`和`ToDoListWebApp`为启动项目。一旦这样做了，我们就可以安全地运行我们的应用，并迎来我们应用的登录页面。点击登录按钮，将被重定向至[login.microsoftonline.com](http://login.microsoftonline.com)；这代表 Azure AD 登录。登录后，您将看到如下登录页面:

![](img/e29198da-d86b-4acc-a219-c9565624f490.png)

您可以在登录应用时观察网络流量和网址重定向，以研究身份令牌的详细交换并获取访问令牌。如果您通过“待办事项”菜单浏览应用，您将能够访问“待办事项”屏幕并向“待办事项”添加项目。这就是我们的`TodoListService`微服务被调用的地方，也是从`TodoWebApp` web 应用获取授权许可的地方。如果您浏览配置文件菜单，您将看到标识令牌返回，以及您的名字、姓氏和电子邮件标识，这显示了 OpenID Connect 正在运行。

如果您想详细研究代码，TodoListService 项目中的`TodoListController.cs`、`Startup.Auth.cs`和`TodoListController.cs`包含有趣的代码片段以及解释性注释。

在这个例子中，我们使用 OAuth 和 OpenID Connect 来保护基于浏览器的用户界面、web 应用和微服务。如果我们在用户界面 web 应用和微服务之间有一个 API 网关，情况可能会有所不同。在这种情况下，我们需要在 web app 和 API 网关之间建立信任。此外，我们必须将标识令牌和访问令牌从网络应用传递到应用编程接口网关。这又会将令牌传递给微服务。但是，在本章的范围内讨论和实现是不可行的。

# 作为应用编程接口网关的 Azure 应用编程接口管理

微服务实现的另一个重要模式是前端的后端。这种模式是由山姆·纽曼引入并流行起来的。BFF 模式的实际实现是通过在各种类型的客户端和微服务之间引入 API 网关来完成的。

如下图所示:

![](img/d10acc55-d9a0-4d01-806d-95039ad04cfc.png)

Azure API Management(以下简称 **Azure APIM** 或简称 **APIM** )正是合适的选择，它可以充当中的 API 网关。基于. NET 的微服务实现。由于 Azure APIM 是云服务之一，它具有超强的可扩展性，可以很好地集成到 Azure 生态系统中。在本章中，我们将重点介绍 Azure APIM 的以下特性。

蔚蓝 APIM 在逻辑上分为三个部分:

*   API 网关:API 网关只是客户端应用和服务之间的代理。它负责以下功能；这些主要被各种应用用来和微服务对话:

    *   接受应用编程接口调用，并将它们路由到后端
    *   验证应用编程接口密钥、JWTs 和证书
    *   支持通过 Azure AD 和 OAuth 2.0 访问令牌进行身份验证
    *   强制实施使用配额和费率限制
    *   无需修改代码即可动态转换您的应用编程接口
    *   缓存设置的后端响应
    *   日志调用元数据进行分析
*   发布者门户:这是组织和发布应用编程接口程序的管理界面。它主要由微服务开发人员使用，以使微服务/应用编程接口对应用编程接口消费者或客户端应用可用。通过这个，API 开发者可以:

    *   定义或导入应用编程接口模式
    *   将原料药包装到产品中
    *   在应用编程接口上设置配额或转换等策略
    *   从分析中获得见解
    *   管理用户
*   开发人员门户:这是应用编程接口消费者的主要网络存在，他们可以在这里做以下事情:

    *   阅读应用编程接口文档
    *   通过交互式控制台尝试应用编程接口
    *   创建一个帐户并订阅它以获取 API 密钥
    *   根据自己的使用情况访问分析

Azure APIM 提供了易于使用的用户界面和良好的文档。Azure 应用编程接口管理还带有其 REST 应用编程接口，因此 Azure APIM 门户的所有功能(您可以看到)都可以通过 Azure APIM 可用的 Azure REST 应用编程接口端点以编程方式实现。

现在，让我们快速了解一下 Azure APIM 中的一些安全相关概念，以及它们如何在微服务中使用:

*   产品:产品只是原料药的集合。它们还包含使用配额和使用条款。
*   策略:策略是应用编程接口管理的动态安全特性。它们允许发布者通过配置改变应用编程接口的行为。策略是根据应用编程接口的请求或响应按顺序执行的语句的集合。API 管理基本上是一个代理，位于 Azure 中托管的微服务和客户端应用之间。由于它是一个中间层，它能够提供额外的服务。这些附加服务是用一种基于 XML 的声明性语法定义的，该语法称为**策略**。蔚蓝 APIM 允许各种政策。事实上，您可以通过组合现有策略来构建自己的自定义策略。一些重要的政策如下:
*   访问限制策略:

    *   检查 HTTP 头:此策略检查 Azure APIM 收到的每个请求中是否存在特定的 HTTP 头或其值。
    *   按订阅限制调用率:此策略根据每个订阅调用特定服务的次数来允许或拒绝对微服务的访问。
    *   限制呼叫方 IP:此策略指的是对 IP 地址进行白盒，因此只有已知的 IP 才能访问服务。
    *   按订阅设置使用配额:此策略允许多次调用。它允许您在每次订阅的基础上强制实施可续订或终身的呼叫量和/或带宽配额。
    *   验证 JWT:此策略验证应用中用于身份验证的 JWT 令牌参数。

*   认证策略:

    *   使用基本身份验证:此策略有助于对传入请求应用基本身份验证。
    *   使用客户端证书进行身份验证:此策略有助于使用客户端证书对应用编程接口网关后面的服务进行身份验证。
*   跨域策略:

    *   允许跨域呼叫:此策略使我们能够通过 Azure APIM 发出 CORS 请求。
    *   CORS:这为端点或微服务增加了 CORS 支持，允许基于浏览器的网络应用进行跨域调用。
    *   JSONP:JSONP 策略为端点或整个微服务添加了 **JSON 填充** ( **JSONP** )支持，以允许来自 Java Script 网络应用的跨域调用。
*   转型政策:

    *   屏蔽内容中的网址:此策略屏蔽响应中的网址；它是通过蓝色 APIM 实现的。
    *   设置后端服务:该策略改变了传入请求的后端服务的行为。

策略的另一个优点是它们可以应用于入站和出站请求。

# 费率限制和配额政策示例

在前面的部分中，我们了解了策略的含义。现在我们来看一个例子。以下是应用于端点的配额策略之一:

```cs
<policies>
  <inbound>
    <!-- Change the quota to immediately see the effect-->
    <rate-limit calls="100" renewal-period="60">
    </rate-limit>
    <quota calls="200" renewal-period="604800">
    </quota>
    <base />
  </inbound>
  <outbound>
    <base/>
  </outbound>
</policies>
```

在本例中，我们限制来自单个用户的传入请求(入站)。所以，一个 API 用户只能在`60`秒内进行`100`调用。如果他们试图在这段时间内打更多的电话，用户会收到一个状态代码为`429`的错误，该代码基本上表示超过了*速率限制*。此外，我们正在为同一用户分配一年内`200`呼叫的配额限制。这种节流行为是保护微服务免受不想要的请求甚至 DOS 攻击的好方法。

Azure APIM 还支持使用 OAuth 2.0 和 OpenID Connect 进行身份验证。在发布者门户中，您可以很容易地看到 OAuth 和 OpenID Connect 选项卡来配置提供者。

# 集装箱安全

Docker 是行业应用容器化的一大部分。随着集装箱的广泛使用，显然我们需要在集装箱周围采取有效的安全措施。如果我们看一下容器的内部架构，它们非常接近主机操作系统内核。

Docker 应用最小特权原则来提供隔离和减少攻击面。尽管有这些进步，但以下几点将帮助您了解可以对容器采取的安全措施:

*   确保用于微服务的所有容器映像都经过签名，并且源自受信任的注册表
*   强化主机环境、守护进程和映像
*   遵循最小权限原则，不要提升对访问设备的访问权限
*   使用 Linux 中的控制组来监视资源，如内存、输入/输出和中央处理器
*   尽管容器存在的时间很短，但是记录所有的容器活动是明智的，对于后期分析来说理解这一点很重要
*   如果可能，将容器扫描过程与工具集成，如 Aqua([http://www.aquasec.com](http://www.aquasec.com))或 Twistlock([https://www.twistlock.com](https://www.twistlock.com))

# 其他安全最佳实践

微服务架构风格是新的，尽管围绕基础设施和编写安全代码的一些安全实践仍然适用。在本节中，让我们讨论其中的一些实践:

*   库和框架的标准化:在开发过程中应该有一个引入新的库和框架或工具的过程。如果发现任何漏洞，这将减轻修补工作；它还将最小化由围绕开发的库或工具的临时实现引入的风险。
*   常规漏洞识别和缓解:使用行业标准漏洞扫描器扫描源代码和二进制文件应该是开发的常规部分。调查结果和观察结果应该像功能缺陷一样得到同等重视。
*   第三方审计和笔测试:外部审计和渗透测试练习非常有价值。应该有进行这种练习的常规做法。这在处理关键任务或敏感数据的应用中非常重要。
*   日志记录和监控:日志记录对于检测攻击和从攻击中恢复是非常有用的技术。在微服务的情况下，具有聚合来自不同系统的日志的能力是必不可少的。河床、AppDynamics 和 Splunk 等工具在这个领域非常有用。
*   防火墙:在网络边界有一个或多个防火墙总是有益的。应该正确配置防火墙规则。
*   网络隔离:在单片的情况下，网络分区受到限制。但是，对于微服务，我们需要在逻辑上创建不同的网段和子网。基于微服务交互模式的分段对于保持和开发额外的安全措施非常有效。

# 摘要

按设计分布的微服务架构风格为我们提供了更好的选项来保护重要的业务关键型系统。传统。基于. NET 的身份验证和授权技术是不够的，不能应用于微服务领域。我们也看到了为什么安全的基于令牌的方法，比如 OAuth 2.0 和 OpenID Connect 1.0，正在成为微服务授权和认证的具体标准。如果您想了解更多与安全相关的一般信息，请访问位于[http://www.owasp.org](http://www.owasp.org)的**开放网络应用安全项目** ( **OWASP** )和位于[https://www.microsoft.com/en-us/sdl/](https://www.microsoft.com/en-us/sdl/)的微软安全开发生命周期。Azure AD 可以很好的支持 OAuth 2.0 和 OpenID Connect 1.0。Azure API Management 还可以充当微服务实现中的 API 网关，并提供漂亮的安全功能，例如策略。

Azure AD 和 Azure API 管理提供了许多强大的功能来监控和记录收到的请求。这将非常有用，不仅对于安全性，而且对于跟踪和故障排除场景。我们将在下一章中看到日志记录、监控以及围绕微服务故障排除的整体检测。