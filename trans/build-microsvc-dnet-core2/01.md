# 微服务简介

本章的重点是让您熟悉微服务。我们先简单介绍一下。然后，我们将定义它们的前辈:单片架构和**面向服务架构** ( **SOA** )。在此之后，我们将看到微服务如何对抗 SOA 和单体架构。然后我们将比较每种建筑风格的优缺点。这将使我们能够确定适合这些风格的场景。我们将理解分层整体架构带来的问题。我们将讨论在整体世界中这些问题的解决方案。最后，我们将能够把一个单一的应用程序分解成一个微服务架构。我们将在本章中讨论以下主题:

*   微服务的起源
*   讨论微服务
*   了解微服务架构
*   微服务的优势
*   SOA 与微服务
*   理解整体建筑风格的问题
*   . NET 堆栈标准化的挑战
*   Azure 服务结构概述

# 微服务的起源

2011 年年中，在一个关于软件架构师的研讨会上，人们首次使用了*微服务*这个术语。2012 年 3 月，詹姆斯·刘易斯展示了他关于*微型服务*的一些想法。到 2013 年底，来自 IT 行业的各种团体开始讨论*微服务*，到 2014 年，它们已经足够受欢迎，被认为是大企业的有力竞争者。

*微服务*没有官方介绍。对这个术语的理解纯粹是基于过去的用例和讨论。我们将详细讨论这一点，但在此之前，让我们看看维基百科([https://en.wikipedia.org/wiki/Microservices](https://en.wikipedia.org/wiki/Microservices))对微服务的定义，它总结为:

"Microservices is a specialization of and implementation approach for SOA used to build flexible, independently deployable software systems."

2014 年，詹姆斯·刘易斯和马丁·福勒走到一起，提供了几个真实世界的例子，用自己的话介绍了*微服务*(参考[http://martinfowler.com/microservices/](http://martinfowler.com/microservices/))，并进一步详述如下:

"The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies."

看到刘易斯和福勒在这里定义的所有属性是非常重要的。他们将其定义为一种架构风格，开发人员可以利用这种风格来开发一个应用程序，该应用程序的业务逻辑分布在一堆小服务中，每个服务都有自己的持久存储功能。此外，请注意它的属性——它可以独立部署，可以在自己的进程中运行，是一种轻量级的通信机制，并且可以用不同的编程语言编写。

我们想强调这个具体的定义，因为它是整个概念的关键。随着我们的前进，当我们读完这本书的时候，它会走到一起。

# 讨论微服务

我们已经过了*微服务*的几个定义；现在，让我们详细讨论一下*微服务*。

简而言之，微服务架构消除了 SOa 的大部分缺点。它比 SOA 服务更面向代码(我们将在接下来的章节中详细讨论这一点)。

将应用程序分割成许多服务既不是 SOA，也不是微服务。然而，将来自 SOA 世界的服务设计和最佳实践与一些新兴实践相结合，例如隔离部署、语义版本控制、提供轻量级服务以及多语种编程中的服务发现，就是微服务。我们实施微服务来满足业务功能，并以更短的上市时间和更大的灵活性来实施它们。

在我们继续理解架构之前，让我们讨论导致其存在的两个重要架构:

*   整体建筑风格
*   前进速度

我们大多数人都知道这样的场景，在企业应用程序开发的生命周期中，决定了一个合适的架构风格。然后，在不同的阶段，初始模式被进一步改进和调整，以适应各种挑战，例如部署复杂性、大代码库和可伸缩性问题。这正是单体架构风格如何演变成 SOA，进而导致微服务的方式。

# 整体建筑

单体建筑风格是一种传统的建筑类型，在行业中得到了广泛的应用。 *monolithic* 这个术语并不新鲜，是从 UNIX 世界借来的。在 UNIX 中，大多数命令作为独立程序存在，其功能不依赖于任何其他程序。如下图所示，我们可以在应用程序中使用不同的组件，例如:

*   用户界面:这处理所有的用户交互，同时用 HTML 或 JSON 或任何其他首选的数据交换格式(在网络服务的情况下)进行响应。
*   业务逻辑:应用于以用户输入、事件和数据库形式接收的输入的所有业务规则都存在于此。
*   数据库访问:这包含了为了查询和持久化对象而访问数据库的完整功能。一个被广泛接受的规则是，它是通过业务模块使用的，而不是直接通过面向用户的组件。

使用这种架构构建的软件是独立的。我们可以想象一个。包含各种组件的. NET 程序集，如下图所示:

![](assets/79da4a6a-3b49-4218-92ab-53786ce242e2.png)

因为软件在这里是独立的，所以它的组件是相互关联和相互依赖的。即使其中一个模块中的简单代码更改也可能会破坏其他模块中的主要功能。这将导致我们需要测试整个应用程序的场景。由于业务严重依赖其企业应用程序框架，这一时间可能非常关键。

让所有组件紧密耦合带来了另一个挑战——每当我们执行或编译这样的软件时，所有组件都应该可用，否则构建将失败；请参考前面的图表，该图表代表单块架构，并且是独立的或单一的。NET 程序集项目。然而，单体架构也可能有多个程序集。这意味着，即使业务层(程序集、数据访问层程序集等)是分离的，在运行时，它们都将聚集在一起，作为一个进程运行。

用户界面依赖于其他组件的直接销售和库存，其方式类似于所有其他相互依赖的组件。在这种情况下，如果没有这些组件中的任何一个，我们将无法执行这个项目。升级其中任何一个组件的过程都将更加复杂，因为我们可能还需要考虑其他需要代码更改的组件。这导致了比实际变更所需的更多的开发时间。

部署这样的应用程序将成为另一个挑战。在部署过程中，我们必须确保每个组件都被正确部署；否则，我们最终可能会在生产环境中面临许多问题。

如前所述，如果我们使用单体架构风格开发应用程序，我们可能会面临以下挑战:

*   大代码库:这是一个代码行比注释多很多的场景。由于组件是互连的，我们将不得不忍受重复的代码库。
*   业务模块太多:这与同一系统内的模块有关。
*   代码库复杂性:由于其他模块或服务中需要修复，这导致代码被破坏的几率更高。
*   复杂的代码部署:您可能会遇到需要整个系统部署的微小变化。
*   影响整个系统的一个模块故障:这与相互依赖的模块有关。
*   可扩展性:这是整个系统所需要的，而不仅仅是其中的模块。
*   模块间依赖:这是由于紧密耦合。
*   螺旋式上升的开发时间:这是由于代码的复杂性和相互依赖性。
*   无法轻松适应新技术:在这种情况下，整个系统都需要升级。

如前所述，如果我们想要减少企业应用程序的开发时间、简化部署并提高软件的可维护性，我们应该避免传统的或单一的架构。

# 面向服务的架构

在前一节中，我们讨论了单片架构及其局限性。我们还讨论了为什么它不适合我们的企业应用程序需求。为了克服这些问题，我们应该采取模块化的方法，我们可以分离组件，这样它们就可以独立出来。NET 程序集。

The main difference between SOA and monolithic is not one or multiple assemblies. As the service in SOA runs as a separate process, SOA scales better compared to monolithic.

我们来讨论一下模块化架构，也就是 SOA。这是一种著名的架构风格，其中企业应用程序被设计为服务的集合。这些服务可能是 RESTful 或 ASMX 网络服务。为了更详细地理解 SOA，我们先来讨论一下*服务*。

# 什么是服务？

在这种情况下，服务是 SOA 的一个基本概念。它可以是向其他系统组件提供功能的一段代码、程序或软件。这段代码可以直接与数据库交互，也可以通过另一个服务间接交互。此外，它可以被客户端直接消费，其中客户端可以是网站、桌面应用、移动应用或任何其他设备应用。参考下图:

![](assets/2fd7f13f-89ce-4f72-a4aa-9a9213a26e40.png)

服务是指由其他系统(通常称为**客户端/客户端应用程序**)公开使用的一种功能。如前所述，它可以由一段代码、程序或软件来表示。这种服务通常通过 HTTP 传输协议公开。然而，HTTP 协议不是一个限制因素，可以选择一个被认为适合该场景的协议。

下图中，**服务-直销**直接与**数据库**交互，三个不同的客户端，即 **Web** 、**桌面**、**移动**正在消费服务。另一方面，我们有客户消费**服务合作伙伴销售**，这与**服务渠道合作伙伴**进行数据库访问。

产品销售服务是一组与客户端应用程序交互并直接或通过另一项服务提供数据库访问的服务，在本例中为**服务–渠道合作伙伴**。在上图所示的**服务直销**中，它为网络商店、桌面应用程序和移动应用程序提供功能。该服务还与数据库进行交互，执行各种任务，即获取和保存数据。

通常，服务通过某种通信通道(通常是 HTTP 协议)与其他系统交互。这些服务可能部署在同一台服务器上，也可能不部署在单台服务器上:

![](assets/3141c324-dfe8-495b-9c05-28436ac2d7df.png)

在上图中，我们已经投影了一个 SOA 示例场景。这里有很多细节需要注意，让我们开始吧。首先，我们的服务可以分布在不同的物理机器上。这里，**服务直销**托管在两台独立的机器上。可能不是整个业务功能，而是只有一部分驻留在**服务器 1** 上，其余的驻留在**服务器 2** 上。类似地，**服务合作伙伴销售**似乎在**服务器 3** 和**服务器 4** 上有相同的安排。然而，这并没有阻止**服务渠道合作伙伴**在两个服务器上作为一个完整的集合托管:**服务器 5** 和**服务器 6** 。

以上图中提到的方式使用一个服务或多个服务的系统称为 **SOA** 。我们将在以下几节中详细讨论 SOA。

让我们回忆一下单片架构。在这种情况下，我们没有使用它，因为它限制了代码的可重用性；它是一个独立的组件，所有组件都是相互连接和相互依赖的。对于部署，在这种情况下，我们必须在选择了 SOA 之后部署我们的完整项目(参考前面的图表和后续的讨论)。现在，由于使用了这种架构风格，我们拥有代码可重用性和易于部署的优势。让我们按照前面的图表来检查一下:

*   可重用性:多个客户端可以使用该服务。该服务也可以被其他服务同时消费。例如 *OrderService* 被 web 和移动客户端消费。现在，*订单服务*也可以被报表仪表盘界面使用。
*   无状态:服务不会在来自客户端的请求之间保持任何状态，也就是说，服务不知道，也不关心后续的请求是否来自已经/还没有发出前一个请求的客户端。
*   基于契约:接口使得它在实现和消费两方面都不依赖于技术。它还可以使其免受底层功能中代码更新的影响。
*   可伸缩性:一个系统可以放大；SOA 可以通过适当的负载平衡进行单独集群。
*   升级:推出新功能或引入现有功能的新版本非常容易。系统不会阻止您保留同一业务功能的多个版本。

# 了解微服务架构

微服务架构是开发包含一组较小服务的单个应用程序的一种方式。这些服务相互独立，并在各自的流程中运行。这些服务的一个重要优势是它们可以独立开发和部署。换句话说，我们可以说微服务是隔离我们的服务的一种方式，因此它们可以在设计、开发、部署和升级的上下文中完全独立地处理。

在单个应用程序中，我们有一个由用户界面、直销和库存组成的独立组件。在微服务架构中，应用程序的服务部分更改为以下描述:

![](assets/685a7b9b-bfd8-4e3b-a27d-1e3708c96738.png)

在这里，业务组件被分离成单独的服务。这些独立的服务现在是早期在独立组件中存在的更小的单元，在整体架构中。直销和库存服务都是相互独立的，虚线描绘了它们在同一个生态系统中的存在，但没有被限制在一个范围内。参考下图:

![](assets/6a664f69-b2ed-4f90-9ad9-9d49d4f2a857.png)

从前面的图中，很明显我们的用户界面可以与任何服务交互。当用户界面调用服务时，不需要干预任何服务。这两个服务相互独立，不知道用户界面何时会调用另一个服务。这两个服务对自己的操作负责，而不对整个系统中的任何其他部分负责。虽然更接近微服务架构，但前面的可视化并不完全是预期微服务架构的完整可视化。

在微服务架构中，服务是小型、独立的单元，有自己的持久存储。

现在，让我们进行最后的更改，以便每个服务都有自己的数据库来保存必要的数据。参考下图:

![](assets/25cb67e0-199e-49d8-84e7-c8ba9a718792.png)

在这里，**用户界面**正在与那些拥有自己独立存储的服务进行交互。在这种情况下，当用户界面调用直接销售服务时，直接销售的业务流程独立于库存服务中包含的任何数据或逻辑来执行。

使用微服务提供的解决方案有很多好处，如下所述:

*   更小的代码库:每个服务都很小，因此作为一个单元更容易开发和部署
*   独立环境的便利性:随着服务的分离，所有开发人员都独立工作，独立部署，没有人担心任何模块依赖性

随着微服务体系结构的采用，单片应用程序现在可以利用相关的优势，因为它现在可以轻松扩展并独立使用服务进行部署。

# 微服务中的消息传递

在处理微服务架构时，仔细考虑消息机制的选择是非常重要的。如果忽略这一个方面，那么它会损害使用微服务架构进行设计的整个目的。在单片应用程序中，这不是一个问题，因为组件的业务功能是通过函数调用来调用的。另一方面，这是通过松散耦合的 web 服务级消息传递功能实现的，其中服务主要基于 SOAP。在微服务消息机制的情况下，它应该是简单和轻量级的。

对于在微服务架构的各种框架或协议之间做出选择，没有固定的规则。不过，这里有几点值得考虑。首先，它应该实现起来足够简单，不会给系统增加任何复杂性。其次，它应该足够轻量级，记住微服务架构可能严重依赖服务间消息传递这一事实。让我们继续考虑同步和异步消息以及不同消息格式的选择。

# 同步消息

当系统期望服务及时响应时，系统会一直等待，直到从服务收到响应，这就是同步消息。剩下的就是微服务最受欢迎的选择。它很简单，支持 HTTP 请求-响应，因此几乎没有空间寻找替代方案。这也是大多数微服务实现使用 HTTP(基于 API 的样式)的原因之一。

# 异步消息传递

当系统没有立即期待服务的及时响应，并且系统可以继续处理而不阻塞该调用时，这就是异步消息传递。

让我们将这个消息传递概念整合到我们的应用程序中，看看它会如何变化和变化:

![](assets/638f247e-d806-47ad-a269-0688d56b6108.png)

# 消息格式

在过去的几年里，使用 MVC 之类的东西让我迷上了 JSON 格式。您也可以考虑 XML。使用应用编程接口风格的资源，这两种格式在 HTTP 上都可以。如果您需要使用二进制消息格式，也很容易获得。我们不推荐任何特定的格式；您可以继续使用任何选定的消息格式。

# 我们为什么要使用微服务？

已经探索了大量的模式和架构，其中一些越来越受欢迎；然而，也有其他公司正在输掉互联网流量之战。每种解决方案都有各自的优缺点，因此对于公司来说，快速响应基本需求变得越来越重要，例如可扩展性、高性能和易于部署。任何一个方面如果不能以成本效益的方式实现，都很容易对大型企业产生负面影响，使盈利和非盈利企业之间产生巨大差异。

这就是我们看到*微服务*拯救企业系统架构师的地方。借助这种建筑风格，他们可以确保他们的设计不会出现前面提到的问题。同样重要的是要考虑这样一个事实，即在尊重所涉时间的同时，以具有成本效益的方式实现这一目标。

# 微服务架构是如何工作的？

到目前为止，我们已经讨论了关于微服务架构的各种事情，现在我们可以描述微服务架构是如何工作的；我们可以根据我们的设计方法使用任何组合，或者赌一个适合它的模式。以下几点有利于微服务架构的工作:

*   这是现代的编程，在现代，我们应该遵循所有的固体原则。是**面向对象编程** ( **OOP** )。
*   最好的方法是将功能公开给其他或外部组件，以便任何其他编程语言都能够使用该功能，而无需遵守任何特定的用户界面，即服务(web 服务、API、rest 服务等)。
*   整个系统按照一种互不关联或相互依赖的协作方式工作。
*   每个组件都有自己的责任。换句话说，组件只负责一个功能。
*   它用分离概念分离代码，分离的代码是可重用的。

# 微服务的优势

现在，让我们试着快速理解微服务在 SOA 和单体架构之前的位置:

*   扩展的成本效益:您不需要投入大量资金来使整个应用程序可扩展。就购物车而言，我们可以简单地对产品搜索模块和订单处理模块进行负载平衡，同时省去不太常用的操作服务，如库存管理、订单取消和交货确认。
*   清晰的代码边界:这个动作应该匹配组织的部门层次结构。在大型企业中，不同的部门赞助产品开发，这可能是一个巨大的优势。
*   更容易的代码更改:代码以一种不依赖于其他模块代码的方式完成，并且只实现独立的功能。如果做得对，那么一个微服务的变化影响另一个微服务的机会是非常小的。
*   易于部署:由于整个应用程序更像是一组相互隔离的生态系统，如果需要，可以一次部署一个微服务。其中任何一个的失败都不会使整个系统瘫痪。
*   技术适配:您可以在一夜之间将单个微服务或一大堆微服务移植到不同的技术上，而您的用户甚至不知道。是的，希望你不要指望我们会告诉你，你需要维护这些服务合同。
*   分布式系统:这是隐含的，但是这里需要提醒一下。确保异步调用使用良好，同步调用不会真正阻塞整个信息流。很好地使用数据分区。我们稍后再谈这个，所以现在不要担心。
*   快速的市场反应:世界竞争是一个明确的优势；否则，如果您对新功能请求或系统内新技术的采用反应迟钝，用户往往会很快失去兴趣。

# SOA 与微服务

如果你对微服务和 SOA 都没有完整的理解，你会混淆两者。从表面上看，微服务的特性和优势听起来几乎像是一个细长版本的 SOA，许多专家认为，事实上不需要一个额外的术语，比如**微服务**，SOA 可以实现微服务布局的所有属性。然而，事实并非如此。有足够的差异从技术上隔离它们。

SOA 的底层通信系统固有地存在以下问题:

*   事实上，在 SOA 中开发的系统依赖于它的组件，组件之间是相互作用的。所以不管你怎么努力，它最终都会在消息队列中面临瓶颈。
*   SOA 的另一个焦点是命令式组合。这样，我们就失去了使一个代码单元相对于面向对象程序可重用的途径。

我们都知道组织在基础设施上的支出越来越多。企业越大，开发的应用程序的所有权问题就越复杂。随着利益相关方数量的增加，满足他们所有不断变化的业务需求变得不可能。这是微服务明显与众不同的地方。虽然云开发不在我们当前的讨论范围内，但说微服务架构的可扩展性、模块化和适应性可以随着云平台的使用而轻松进一步扩展，这并不会损害我们。是时候改变了。

# 微服务架构的先决条件

了解微服务架构实现所产生的生态系统非常重要。微服务的影响不仅仅是操作前的。任何选择微服务架构的组织都会发生如此深刻的变化，以至于如果他们没有做好充分的准备来处理它，用不了多久优势就会变成劣势。

在同意采用微服务架构后，明智的做法是具备以下先决条件:

*   部署和质量保证:需求将变得更加苛刻，开发需求的转变也更快。这需要您尽快部署和测试。如果只是少量的服务，那就不成问题了。然而，如果服务数量增加，它可能会很快挑战现有的基础设施和实践。例如，您的质量保证和试运行环境可能不再足以测试开发团队返回的构建数量。
*   开发和运营团队的协作平台:随着应用程序进入公共领域，用不了多久，开发对质量保证的古老脚本就会再次上演。这一次的不同之处在于，业务将处于危险之中。因此，您需要准备好以自动化方式快速响应，以便在需要时识别根本原因。
*   监控框架:随着微服务数量的增加，您将很快需要一种方法来监控整个系统的功能和运行状况，以发现任何可能的瓶颈或问题。如果没有任何方法来监控已部署的微服务的状态以及由此产生的业务功能，任何团队都不可能采取主动部署方法。

# 理解整体建筑风格的问题

在这一节中，我们将讨论单片集成电路的所有问题。NET 基于堆栈的应用程序。在单片应用中，核心问题是:很难扩展单片。最终得到的应用程序拥有非常大的代码库，并在可维护性、部署和修改方面带来了挑战。

# . NET 堆栈标准化的挑战

在单片应用技术中，堆栈依赖阻止了外部世界最新技术的引入。当前的堆栈带来了挑战，因为 web 服务本身也面临一些挑战:

*   安全性:没有办法通过网络服务来识别用户(在强身份验证方案上没有明确的共识)。想象一下，一个银行应用程序发送未加密的数据，其中包含未经加密的用户凭据。所有提供免费无线网络的机场、咖啡馆和公共场所都很容易成为身份盗窃和其他网络犯罪的受害者。
*   响应时间:虽然 web 服务本身在整个体系结构中提供了一些灵活性，但是由于服务本身所花费的大量处理时间，它很快就减少了。因此，在这种情况下，web 服务没有任何问题。一个单一的应用程序包含大量的代码，这是事实；复杂的逻辑使得 web 服务的响应时间很长，因此不可接受。
*   吞吐率:这是偏高的，结果会妨碍后续操作。依赖于对库存 web 服务的调用的结帐操作，必须搜索几百万条记录，这不是一个坏主意。但是，当同一库存服务为整个门户的主要产品搜索/浏览提供服务时，可能会导致业务损失。十次服务呼叫中有一次失败将意味着业务的转化率降低 10%。
*   频繁停机:由于 web 服务是整个整体生态系统的一部分，因此每次升级或应用程序出现故障时，它们必然会停机且不可用。这意味着外部世界对应用程序 web 服务的任何 B2B 依赖的存在将进一步使决策复杂化，从而寻求停机时间。这绝对让系统的小升级看起来很贵；因此，这进一步增加了待定系统升级的积压。
*   技术采用:为了采用或升级技术堆栈，需要升级、测试和部署整个应用程序，因为模块是相互依赖的，项目的整个代码库都会受到影响。考虑支付网关模块使用需要合规性相关框架升级的组件。开发团队别无选择，只能升级框架本身，并仔细检查整个代码库，以抢先识别任何代码中断。当然，这仍然不排除生产崩溃，但这很容易让即使是最好的架构师和经理也会流汗和失眠。

**可用性**:服务运行的时间百分比。

**响应** **时间**:服务响应所花费的时间。

**吞吐量**:处理请求的速率。

# 容错

单片应用程序具有高度的模块依赖性，因为它们紧密耦合。不同的模块以模块内的方式利用功能，由于级联效应，即使单个模块故障也会导致系统停机，这与多米诺骨牌倒下非常相似。我们都知道，一个用户得不到产品搜索的结果，远没有整个系统崩溃那么严重。

使用 web 服务的解耦传统上是在架构级别尝试的。对于数据库级策略，ACID 已经被依赖了很长时间。让我们进一步研究这两点:

*   网络服务:在当前的单一应用程序中，客户体验由于这个原因而降低。即使当客户试图下订单时，诸如 web 服务的高响应时间甚至服务本身的完全失败之类的原因也会导致无法成功下订单。甚至没有一次失败是可以接受的，因为用户倾向于记住他们最后的经历，并假设可能会重复。这不仅会导致可能的销售损失，还会失去未来的商业前景。Web 服务的故障会导致依赖它们的系统出现级联故障。
*   ACID: ACID 是原子性、一致性、隔离性和持久性的缩写；这是数据库中的一个重要概念。它是存在的，但它是好事还是坏事要根据综合表现的总和来判断。它处理数据库级别的故障，毫无疑问，它确实提供了一些防止数据库错误蔓延的保险。同时，每个 ACID 操作都会妨碍/延迟其他组件/模块的操作。需要非常仔细地判断它造成的伤害大于益处的程度。

# 缩放比例

不同通信手段的可用性、获取信息的便利性和开放的世界市场等因素正导致企业快速增长，同时实现多样化。随着业务的快速增长，越来越需要适应不断增长的客户群。扩展是任何企业在努力迎合不断增长的用户群时面临的最大挑战之一。

**可伸缩性**只不过是系统/程序更好地处理工作增长的能力。换句话说，可伸缩性是系统/程序扩展的能力。

在开始下一部分之前，让我们详细讨论和理解扩展，因为这将是我们从单片服务过渡到微服务的练习中不可或缺的一部分。

系统的可伸缩性是它处理不断增加的工作负载的能力。有两种主要的可伸缩性策略或类型可以扩展我们的应用程序。

# 垂直扩展或向上扩展

在纵向扩展中，我们分析现有的应用程序，找出模块中由于执行时间较长而导致应用程序变慢的部分。提高代码的效率可能是减少内存消耗的一个策略。这个减少内存消耗的练习可以针对特定的模块或整个应用程序。另一方面，由于该策略涉及明显的挑战，我们可以向现有的信息技术基础架构添加更多资源，例如升级内存或添加更多磁盘驱动器，而不是更改应用程序。垂直缩放中的这两种路径都有其有益程度的限制。在一个特定的时间点之后，最终的收益将趋于平稳。请务必记住，这种扩展需要停机。

# 水平扩展或横向扩展

在水平扩展中，我们深入挖掘对整体性能有较大影响的模块，例如高并发性；因此，这将使我们的应用程序能够为我们不断增长的用户群提供服务，用户群现在已经达到百万大关。我们还实现了负载平衡来处理更多的工作。向集群添加更多服务器的选项不需要停机，这是一个明显的优势。每个案例都有所不同，因此电力、许可证和冷却的额外成本是否值得，以及达到什么程度，将根据具体情况进行评估。

扩展将在第 8 章*扩展微服务*中详细介绍。

# 部署挑战

当前的应用程序也面临部署挑战。它被设计为一个整体应用程序，订单模块中的任何更改都需要重新部署整个应用程序。这很耗时，而且每次改变都要重复整个周期。这意味着这可能是一个频繁的循环。在这种情况下，缩放只能是一个遥远的梦想。

正如关于扩展的讨论一样，当前的应用程序存在部署挑战，需要我们部署整个程序集，模块是相互依赖的，并且它是. NET 的单个程序集应用程序。一次性部署整个应用程序也使测试我们的应用程序的整个功能成为强制性的。这种做法的影响将是巨大的:

*   高风险部署:一次性部署整个解决方案或应用程序会带来很高的风险，因为所有模块都将被部署，即使其中一个模块发生了单次更改。
*   更长的测试时间:因为我们必须部署完整的应用程序，所以我们必须测试整个应用程序的功能。没有测试我们不能直播。由于更高的相互依赖性，更改可能会导致其他模块出现问题。
*   计划外停机:完整的生产部署需要对代码进行全面测试，因此我们需要安排生产部署。这是一项耗时的任务，会导致大量停机。虽然计划停机，但在此期间，由于系统不可用，业务和客户都会受到影响；这可能会给企业造成收入损失。
*   生产缺陷:无缺陷的部署将是任何项目经理的梦想。然而，这与现实相去甚远，每个团队都害怕这种可能性。单片应用程序与这种情况没有什么不同，解决生产缺陷说起来容易做起来难。这种情况只会变得更加复杂，因为之前的一些 bug 仍然没有解决。

# 组织一致性

在单片应用程序中，拥有庞大的代码库并不是您将面临的唯一挑战。拥有一个庞大的团队来处理这样的代码库是影响业务和应用程序增长的另一个问题。

*   同一个目标:在一个团队中，所有的团队成员都有同一个目标，那就是每天结束时及时无 bug 的交付。但是，由于拥有大量的代码库和当前的，单一的架构风格对于团队成员来说并不是一种舒服的感觉。由于相互依赖的代码和相关的可交付成果，团队成员是相互依赖的，在代码中体验到的同样的效果也存在于开发团队中。在这里，每个人都在争先恐后地努力完成工作。互相帮助或尝试新事物的问题不会出现。总之，团队不是一个自组织的团队。

罗伊·奥谢洛夫在他的著作《团队领导者》中定义了团队的三个阶段:

**生存阶段**:没时间学习。

**学习阶段**:学习解决自己的问题。

**自组织阶段**:促进，实验。

*   另一种观点:开发团队花费太多时间来完成交付，这是由于一些原因，例如功能增强、错误修复或模块间的相互依赖，阻碍了简单的开发。质量保证团队依赖于开发团队，而开发团队有自己的问题。一旦开发人员开始处理 bug、修复或特性增强，质量保证团队就会陷入困境。没有单独的环境或构建可供质量保证人员进行测试。这种延迟阻碍了整体交付，客户或最终用户将无法按时获得新功能或修复。

# 模块性

关于我们的单片应用，我们可能有一个订单模块，模块*订单*的变化会影响模块*库存*等等。正是模块化的缺失导致了这种情况。

这也意味着我们不能在另一个模块中重用一个模块的功能。代码没有被分解成可重用的结构化片段，以节省时间和精力。代码模块中没有隔离，因此没有通用代码可用。

业务在增长，客户也在突飞猛进。来自不同地区的新客户或现有客户在使用该应用程序时有不同的偏好。有些人喜欢访问网站，但其他人更喜欢使用移动应用程序。该系统的结构使得我们无法在一个网站和一个移动应用中共享组件。这使得为企业推出移动/设备应用成为一项具有挑战性的任务。业务受到影响，因为在这种情况下，公司会失去更喜欢移动应用的客户。

替换组件应用程序的困难在于使用第三方库、支付网关等外部系统和外部订单跟踪系统。在当前风格的整体架构应用程序中替换旧组件是一项乏味的工作。例如，如果我们考虑升级消耗外部订单跟踪系统的模块库，那么整个更改将会非常困难。此外，用另一个支付网关替换我们的支付网关将是一项复杂的任务。

在前面的任何场景中，每当我们升级组件时，我们都会升级应用程序中的所有内容，这需要对系统进行完整的测试，并且需要大量的停机时间。除此之外，升级可能会导致生产错误，这将要求您重复整个开发、测试和部署周期。

# 大数据库

我们当前的应用程序有一个庞大的数据库，其中包含一个带有大量索引的模式。当涉及到微调性能时，这种结构提出了一项具有挑战性的工作:

*   单一模式:数据库中的所有实体都集中在一个名为 *dbo* 的单一模式下。这又一次妨碍了业务，因为对于属于不同模块的各种表，单一模式很混乱；例如，客户表和供应商表属于同一个模式，即 *dbo* 。
*   众多的存储过程:目前，数据库中有大量的存储过程，这些存储过程也包含了大量的业务逻辑。有些计算是在存储过程中执行的。因此，当优化这些存储过程或者将它们分解成更小的单元时，这些存储过程被证明是一项令人困惑的任务。

无论何时计划部署，团队都必须密切关注每个数据库更改。这同样是一项耗时的工作，很多时候甚至比构建和部署工作本身还要复杂。

# 微服务的先决条件

为了更好地理解，让我们举一个 FlixOne Inc .的假想例子。以这个例子为基础，让我们详细讨论所有的概念，看看准备好微服务是什么样子的。

FlixOne 是一家遍布印度的电子商务玩家(卖书)。他们正以非常快的速度增长，同时实现业务多元化。他们已经把现有的系统建立在。NET 框架，而且是传统的三层架构。他们有一个庞大的数据库，是这个系统的核心，在他们的生态系统中还有外围应用。其中一个这样的应用程序是为他们的销售和物流团队准备的，它恰好是一个安卓应用程序。这些应用程序连接到其集中式数据中心，并面临性能问题。FlixOne 有一个由外部顾问支持的内部开发团队。参考下图:

![](assets/d11753da-6849-4002-b694-3c4fdbd1e65f.png)

上图描述了我们当前应用程序的广义，它是一个单一的。NET 程序集应用程序。这里我们有用户界面，用于搜索、订购、产品、跟踪订单和结账。现在看下图:

![](assets/4a389244-b808-4d0d-a43b-8e892ac8df1c.png)

上图仅描述了我们的**购物** **购物车**模块。该应用程序是用 C#、MVC5 和实体框架构建的，并且它有一个单独的项目应用程序。这张图片只是我们的应用程序架构的图示概述。这个应用程序是基于网络的，可以从任何浏览器访问。最初，任何使用 HTTP 协议的请求都会到达使用 MVC5 和 JQuery 开发的用户界面。对于购物车活动，UI 与**购物车**模块交互，这个模块无非是一个业务逻辑层，进一步与数据库层对话(用 C#编写)；数据保存在数据库中。

# 应用程序的功能概述

在这里，我们将了解 FlixOne 书店应用程序的功能概述。这只是为了可视化我们的应用程序。以下是购物车之前应用程序的简化功能概述:

![](assets/00ff0f90-44cd-479f-a584-90d81d3bf0fc.png)

在当前应用程序中，客户登录到主页，在那里他们可以看到特色/突出显示的书籍。如果他们没有找到自己喜欢的书，他们可以选择搜索一本书。在获得期望的结果后，顾客可以选择书籍项目并将其添加到他们的购物车中。顾客可以在最后结账前核实图书项目。一旦客户决定结账，现有的购物车系统会将他们重定向到外部支付网关，支付您需要为购物车中的图书支付的指定金额。

如前所述，我们的应用程序是一个整体应用程序；它的结构是作为一个单元来开发和部署的。这个应用程序有一个仍在增长的庞大代码库。小更新需要一次部署整个应用程序。

# 应对当前挑战的解决方案

业务增长很快，所以我们决定在 20 多个城市开设我们的电子商务网站；然而，我们仍然面临着现有应用程序的挑战，并努力为现有用户群提供适当的服务。在这种情况下，在我们开始过渡之前，我们应该让我们的单片应用程序为过渡到微服务做好准备。

在第一种方法中，**购物车**模块将被分成更小的模块，然后您将能够使这些模块相互交互，以及与外部或第三方软件交互:

![](assets/a4add087-5d56-44cd-aecc-1553d1a1ae19.png)

这个提议的解决方案对于我们现有的应用程序来说是不够的，尽管开发人员能够划分代码并重用它。但是，业务逻辑的内部处理将保持不变，不会改变它与用户界面或数据库交互的方式。新代码将与用户界面和数据库层交互，而数据库仍然保持为同一个旧的单一数据库。随着我们的数据库保持不可分割和紧密耦合的层，必须更新和部署整个代码库的问题仍然存在。所以这个方案不适合解决我们的问题。

# 处理部署问题

在前一节中，我们讨论了当前面临的部署挑战。NET 单片应用程序。在本节中，让我们来看看如何通过在相同的环境中进行一些实践来克服这些挑战。NET 堆栈。

用我们的。NET 单片应用程序，我们的部署由 XCOPY 部署组成。在将我们的模块划分为不同的子模块后，我们可以借助这些子模块来适应部署策略。我们可以简单地部署我们的业务逻辑层或一些常见的功能。我们可以适应持续的集成和部署。XCOPY 部署是一个将所有文件复制到服务器的过程，主要用于 web 项目。

# 制造更好的单片应用

我们了解现有单片应用面临的所有挑战。我们必须更好地服务于我们的新增长。随着我们的广泛发展，我们不能错过获得新客户的机会。如果我们错过了解决任何挑战，那么我们也会失去商业机会。让我们讨论几个点来解决这些问题。

# 引入依赖注入

我们的模块是相互依赖的，因此由于一个模块中的变化，我们面临着一些问题，例如代码的可重用性和未解决的 bug。这些是部署挑战。为了解决这些问题，让我们分离我们的应用程序，这样我们就能够将模块分成子模块。我们可以这样划分我们的`Order`模块，它将实现接口，这可以从构造函数启动。这里有一个小代码片段，展示了我们如何在现有的单块应用程序中应用它。

下面是一个代码示例，展示了我们的`Order`类，其中我们使用了构造函数注入:

```
    namespace FlixOne.BookStore.Common
    {
      public class Order : IOrder
      {
        private readonly IOrderRepository _orderRepository;
        public Order(IOrderRepository orderRepository)
        {
          _orderRepository = orderRepository;
        }
        public OrderModel GetBy(Guid orderId)
        {
          return _orderRepository.Get(orderId);
        }
      }
    }
```

The inversion of control, or IoC, is nothing but a way in which objects do not create other objects on whom they rely to do their work.

在前面的代码片段中，我们抽象了我们的`Order`模块，这样它就可以使用`IOrder`接口。之后，我们的`Order`类实现了`IOrder`接口，通过使用控制反转，我们创建了一个对象，因为这是在控制反转的帮助下自动解决的。

此外，`IOrderRepository`和`OrderRepository`的代码片段如下:

```
    namespace FlixOne.BookStore.Common
    {
      public interface IOrderRepository
      {
        OrderModel Get(Guid orderId);
      }
    }
    namespace FlixOne.BookStore.Common
    {
      public class OrderRepository : IOrderRepository
      {
        public OrderModel Get(Guid orderId)
        {
          //call data method here
          return new OrderModel
          {
            OrderId = Guid.NewGuid(),
            OrderDate = DateTime.Now,
            OrderStatus = "In Transit"
          };
        }
      }
    }
```

这里我们试图展示我们的`Order`模块是如何抽象的。在前面的代码片段中，我们返回订单的默认值，只是为了演示实际问题的解决方案。

最后，我们的表示层(MVC 控制器)将使用可用的方法，如下面的代码片段所示:

```
    namespace FlixOne.BookStore.Controllers
    {
      public class OrderController : Controller
      {
        private readonly IOrder _order;
        public OrderController(IOrder order)
        {
          _order = order;
        }
        // GET: Order
        public ActionResult Index()
        {
          return View();
        }
        // GET: Order/Details/5
        public ActionResult Details(string id)
        {
          var orderId = Guid.Parse(id);
          var orderModel = _order.GetBy(orderId);
          return View(orderModel);
        } 
      }
    }
```

下面是一个类图，描述了我们的接口和类如何相互关联，以及它们如何公开它们的方法、属性等等:

![](assets/e9cc6a5f-cd04-4cdc-b38b-9ebc6f37e301.png)

在这里，我们再次使用构造函数注入，其中`IOrder`被传递并得到了初始化的`Order`类；因此，所有的方法在我们的控制器中都是可用的。

通过实现这一点，我们将克服一些问题，例如:

*   减少模块依赖:随着`IOrder`在我们的应用中的引入，我们正在减少`Order`模块的相互依赖。这样，如果我们需要在该模块中添加或移除任何东西，那么其他模块将不会受到影响，因为`IOrder`仅由`Order`模块实现。假设我们想对我们的`Order`模块进行增强；它不会影响我们的`Stock`模块。这样，我们减少了模块的相互依赖性。
*   引入代码可重用性:如果需要获取任何应用程序模块的订单详细信息，可以使用`IOrder`类型轻松实现。
*   代码可维护性的改进:我们现在已经将我们的模块划分为子模块或类和接口。我们现在可以以这样一种方式来构造我们的代码，即所有的类型，也就是所有的接口，都放在一个文件夹下，并遵循存储库的方式。有了这种结构，我们将更容易安排和维护代码。
*   单元测试:我们目前的单片应用程序没有任何类型的单元测试。随着接口的引入，我们现在可以轻松地执行单元测试，并轻松地采用测试驱动开发的系统。

# 数据库重构

如前一节所述，我们的应用程序数据库非常庞大，依赖于单个模式。重构时应该考虑这个庞大的数据库。我们将这样做:

*   模式修正:在一般实践中(不需要)，我们的模式描述了我们的模块。如前几节所述，我们庞大的数据库只有一个模式，那就是 *dbo* 现在，代码或表的每个部分都不应该与 *dbo* 相关。可能有几个模块会与特定的表交互。例如，我们的`Order`模块应该包含一些相关的模式名，比如`Order`。因此，每当我们需要使用该表时，我们可以将它们与自己的模式一起使用，而不是通用的 *dbo* 模式。这不会影响与如何从数据库中检索数据相关的任何功能。但是它会以这样一种方式构建或排列我们的表，即我们能够识别每个表并将其与它们的特定模块相关联。当我们处于将单一应用程序转换为微服务的阶段时，这个练习将非常有帮助。请参考下图:

![](assets/a1b50f7f-e505-439c-9769-d9a94c28a4ca.png)

在上图中，我们看到了数据库模式是如何逻辑分离的。它在物理上没有分离——我们的**订单模式**和**库存模式**属于同一个数据库。因此，这里我们在逻辑上而不是物理上分离数据库模式。

我们还可以以我们的用户为例，并非所有用户都是管理员或属于特定的区域。但是我们的用户表应该以这样一种方式来构造，即我们应该能够通过表名或它们的构造方式来识别用户。在这里，我们可以根据区域来构建我们的用户表。我们应该将我们的用户表映射到一个区域表，这样它就不会影响或改变现有的代码库。

*   将业务逻辑从存储过程转移到代码:在当前的数据库中，我们有数千行存储过程，其中包含大量业务逻辑。我们应该将业务逻辑转移到我们的代码库中。在我们的整体应用程序中，我们使用实体框架；在这里，我们可以避免创建存储过程。我们可以将所有的业务逻辑合并到代码中。

# 数据库分片和分区

在数据库分片和分区之间，我们可以使用数据库分片，将它分解成更小的数据库。这些较小的数据库将部署在单独的服务器上:

![](assets/08fd7ec2-279c-422a-b8dc-812dfe6127b2.png)

一般来说，数据库分片简单地定义为大型数据库的*无共享*分区方案。这样，我们可以实现更高水平的高性能和可扩展性。分片来自*分片*和传播，这意味着将一个数据库分成块(分片)并传播到不同的服务器。

上图是如何将我们的数据库划分成更小的数据库的示意图。请看下图:

![](assets/c8dc4d8d-b6ef-4f07-9a30-cc7e5eaa49a1.png)

# 德沃普斯文化

在前面几节中，我们与团队讨论了挑战和问题。在这里，我们向 DevOps 团队提出了一个解决方案:应该强调开发团队与另一个运营团队的协作。我们应该建立一个开发、质量保证和基础设施团队协作的系统。

# 自动化

基础设施设置可能是一项非常耗时的工作；当基础设施准备就绪时，开发人员将保持闲置。他们需要一些时间才能加入团队并做出贡献。基础架构设置的过程不应该阻止开发人员提高工作效率，因为这会降低整体工作效率。这应该是一个自动化的过程。使用 Chef 或 PowerShell，我们可以轻松创建虚拟机，并在需要时快速增加开发人员数量。这样，我们的开发人员就可以在加入团队的第一天开始工作。

Chef 是一个 DevOps 工具，它提供了一个自动化和管理基础设施的框架。

PowerShell 可以用来创建我们的 Azure 机器和设置 TFS。

# 测试

我们将引入自动化测试，作为我们之前的问题的解决方案，这些问题是我们在部署期间进行测试时面临的。在解决方案的这一部分，我们必须将我们的测试方法划分如下:

*   采用**测试驱动开发** ( **TDD** )。使用 TDD，开发人员需要测试他或她自己的代码。测试只不过是另一段代码，可以验证功能是否按预期工作。如果发现任何功能不满足测试代码，则相应的单元测试失败。这个功能很容易修复，因为你知道这就是问题所在。为了实现这一点，我们可以利用框架，如微软测试或单元测试。
*   质量保证团队可以使用脚本来自动化他们的任务。他们可以利用 QTP 或硒框架创建脚本。

# 版本控制

当前的系统没有任何类型的版本控制系统，所以如果在变更期间发生了什么，就没有办法恢复。为了解决这个问题，我们需要引入一个版本控制机制。在我们的例子中，这应该是 TFS 或吉特。通过使用版本控制，我们现在可以返回到我们的更改，以防发现它破坏了某些功能或在应用程序中引入了任何意外行为。我们现在能够在个人层面上跟踪在这个应用程序上工作的团队成员所做的更改。然而，在我们的单片应用程序中，我们没有这样做的能力。

# 部署

在我们的应用程序中，部署是一个巨大的挑战。为了解决这个问题，我们引入**持续集成** ( **CI** )。在这个过程中，我们需要设置一个 CI 服务器。随着 CI 的引入，整个过程实现了自动化。只要任何团队成员使用版本控制 TFS 或 Git 签入代码，在我们的例子中，配置项过程就开始运行。它确保新代码被构建，单元测试与集成测试一起运行。无论是成功构建的场景还是其他场景，团队都会被告知结果。这使团队能够快速响应问题。

接下来，我们转向持续部署。这里我们介绍各种环境，即开发环境、试运行环境、质量保证环境等等。现在，只要代码被任何团队成员签入，CI 就会开始工作。它调用单元/集成测试套装，构建系统，并将其推到我们已经设置的各种环境中。这样，开发团队为质量保证提供合适构建的周转时间被减少到最小。

# 确定单片中的分解候选项

我们现在已经清楚地确定了当前 FlixOne 应用程序架构及其生成的代码给开发团队带来的各种问题。此外，我们了解开发团队无法应对哪些业务挑战以及原因。

这并不是团队能力不够——这只是代码。让我们继续检查一下，对于我们需要转移到微服务风格架构的 FlixOne 应用程序的各个部分，最好的策略是什么。您应该知道，您有一个具有整体架构的候选人，这在以下某个方面造成了问题:

*   集中部署:虽然这发生在整个过程的最后阶段，但它需要更多的尊重，这是正确的。这里需要理解的是，这个因素从识别和设计的最初阶段就塑造和定义了整个开发策略。这里有一个例子:企业要求你解决两个同等重要的问题。其中一个问题可能需要您对更多的相关模块进行测试，而另一个问题的解决方案可能允许您通过有限的测试逃脱惩罚。不得不做出这样的选择是错误的。企业不应该选择做出这样的选择。
*   代码复杂性:拥有更小的团队是这里的关键。您应该能够为与单一功能相关的变更分配小型开发团队。小团队由一两个成员组成。除此之外，还需要一个项目经理。这意味着一些东西在模块之间比它应该的更加相互依赖。
*   技术采用:您应该能够在不破坏东西的情况下将组件升级到新版本或不同的技术。如果你必须考虑依赖它的组件，你有不止一个候选。即使您不得不担心这个组件所依赖的模块，您仍然有多个候选模块。我记得我的一个客户有一个专门的团队来测试正在发布的技术是否适合他们的需求。我后来了解到，他们实际上会移植其中一个模块，并测量整个系统的性能影响、工作量要求和周转时间。不过，我不同意这一点。
*   高资源:在我看来，系统中的所有东西，从内存、CPU 时间和 I/O 需求，都应该被视为一个模块。如果任何一个模块花费更多的时间和/或更频繁，它应该被挑选出来。在任何涉及高于正常内存的操作中，处理时间会阻塞延迟，输入/输出会让系统等待；这对我们来说是件好事。
*   人的依赖性:如果跨模块移动团队成员看起来工作太多，那么你有更多的候选人。开发人员很聪明，但如果他们在大型系统上挣扎，那不是他们的错。将系统分解成更小的单元，开发人员将会更加舒适和高效。

# 重要的微服务优势

我们已经完成了确定迁移到微服务的候选人的第一步。了解微服务提供的相应优势是值得的。

# 技术独立性

由于每个微服务彼此独立，我们现在有能力为每个微服务使用不同的技术。支付网关可能使用最新的。NET 框架，而产品搜索可以转移到任何其他编程语言。

整个应用程序可以基于用于数据存储的 SQL 服务器，而库存可以基于 NoSQL。灵活性是无限的。

# 相互依赖消除

由于我们试图在每个微服务中实现独立的功能，因此很容易在每个微服务中添加新功能、修复 bug 或升级技术。这对其他微服务没有影响。现在，您有了垂直代码隔离，这使您能够执行所有这些操作，并且部署速度仍然一样快。

这还没有结束。FlixOne 团队现在有能力在现有支付网关的基础上发布一个新的支付网关选项。两个支付网关可以共存，直到团队和企业所有者都对报告感到满意。这就是这个建筑的巨大力量发挥作用的地方。

# 与业务目标保持一致

企业主不一定能理解为什么某个特性更难实现或更耗时。他们的责任是继续推动业务并不断发展。开发团队应该成为业务目标的支点，而不是拦路虎。

理解快速响应业务需求和适应营销趋势的能力不是微服务的副产品，而是它们的目标，这一点非常重要。

用较小的团队实现这一点的能力只会使它更适合企业所有者。

# 成本效益

每个微服务都成为企业的一项投资，因为它可以很容易地被其他微服务使用，而不必一次又一次地重复相同的代码。每次重用一个微服务，都可以通过避免测试和部署该部分来节省时间。

用户体验得到增强，因为停机时间要么被消除，要么被减少到最小。

# 易于扩展

有了垂直隔离，每个微服务都向整个系统提供特定的服务，就很容易扩展。不仅对缩放候选对象的识别更容易，而且成本更低。这是因为我们只扩展了整个微服务生态系统的一部分。

这项工作对企业来说可能是成本密集型的；因此，业务团队现在可以选择首先扩展哪个微服务的优先级。这个决定不再是开发团队的选择。

# 安全

安全性类似于传统分层架构提供的安全性；微服务可以同样容易地得到保护。不同的配置可以用来保护不同的微服务。您可以将微服务生态系统的一部分放在防火墙后面，另一部分用于用户加密。面向 Web 的微服务的安全性可以不同于其他微服务。您可以根据选择、技术或预算来满足您的需求。

# 数据管理

在大多数单一应用程序中，拥有一个数据库是很常见的。几乎总是有一个数据库架构师或指定的所有者负责其完整性和维护。任何需要更改数据库的应用程序增强的路径都必须经过这条路线。对我来说，这从来都不是一件容易的事情。这进一步减缓了应用程序增强、可伸缩性和技术采用的过程。

因为每个微服务都有自己的*独立的*数据库，所以与数据库中所需更改相关的决策可以很容易地委托给各自的团队。我们不必担心对系统其他部分的影响，因为不会有任何影响。

同时，数据库的这种分离带来了团队变得自组织的可能性。他们现在可以开始实验了。

例如，团队现在可以考虑使用 Azure Table 存储或 Azure Redis Cache 来存储大量的产品目录，而不是数据库，就像目前正在做的那样。该团队现在不仅可以进行实验，而且他们的经验可以按照其他团队的要求，以他们方便的时间表的形式在整个系统中轻松复制。

事实上，没有什么能阻止 FlixOne 团队现在的创新和同时使用多种可用技术，然后比较现实世界中的性能并做出最终决定。一旦每个微服务都有了自己的数据库，FlixOne 就会变成这样:

![](assets/35e9fcee-fb33-4950-80fb-39ffd76fdebc.png)

# 集成单片

无论何时选择从单一架构转向微服务风格的架构，计划的时间和成本轴都会带来一些阻力。业务评估可能会禁止移动整体应用程序中没有为过渡提供业务案例的部分。

如果我们从一开始就开发应用程序，情况会有所不同。然而，在我看来，这也是微服务的力量。对整个单芯片架构的正确评估可以安全地识别稍后要移植的单芯片器件。

然而，为了确保这些孤立的部分在未来不会对其他微服务造成问题，我们必须采取一种防范风险的措施。

单片应用程序的这些部分的目标是使它们以与其他微服务相同的方式进行通信。这样做涉及到各种模式，您可以利用开发单片应用程序的技术堆栈。

如果使用事件驱动模式，请确保单体应用程序可以发布和使用事件，包括对源代码的详细修改，以使这些操作成为可能。这个过程也可以通过创建发布和消费事件的事件代理来执行。然后，事件代理可以将这些事件翻译成单片应用程序，以便将源代码中的更改保持在最低限度。最终，数据库将保持不变。

如果您计划使用应用编程接口网关模式，请确保您的网关能够与单一应用程序通信。为了实现这一点，一个选择是修改应用程序的源代码，以公开网关可以轻松使用的 RESTful 服务。这也可以通过创建一个单独的微服务来实现，该微服务将整体应用程序作为 REST 服务公开。创建一个单独的微服务可以避免源代码的大变化。然而，它需要维护和部署新的组件。

# Azure 服务结构概述

当我们在讨论微服务时。NET 核心世界，Azure 服务结构是广泛用于微服务的名称。在本节中，我们将讨论结构服务。

这是一个帮助我们轻松打包、部署和管理可扩展且可靠的微服务的平台(容器也类似于 Docker，等等)。由于复杂的基础设施问题等等，有时很难专注于作为开发人员的主要职责。在 Azure 服务结构的帮助下，开发人员无需担心基础设施问题。

这捆绑并拥有 Azure SQL 数据库、Cosmos DB、微软 Power BI、Azure 事件中心、Azure 物联网中心以及更多核心服务的强大功能。

根据官方文件([https://docs . Microsoft . com/en-us/azure/service-fabric/service-fabric-概述](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview) ) [:](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-overview)

*   服务结构—任何操作系统、任何云:您只需创建一个服务结构集群，该集群运行在 Azure(云)上或内部、Linux 上或 Windows 服务器上。此外，您还可以在其他公共云上创建集群。
*   服务结构-无状态和有状态微服务:是的，在服务结构的帮助下，您可以将应用程序构建为无状态和/或有状态的。

"As per official documentation ([https://docs.microsoft.com/en-us/azure/service-fabric/](https://docs.microsoft.com/en-us/azure/service-fabric/)) of microservices:
Stateless microservices (such as protocol gateways and web proxies) do not maintain a mutable state outside a request and its response from the service. Azure Cloud Services worker roles are an example of a stateless service. Stateful microservices (such as user accounts, databases, devices, shopping carts, and queues) maintain a mutable, authoritative state beyond the request and its response."

*   对应用程序生命周期管理的全面支持:借助服务结构，获得包括开发部署等在内的整个应用程序生命周期的支持。
*   您可以开发一个可扩展的应用程序。更多信息请参考:[https://docs . Microsoft . com/en-us/azure/service-fabric/service-fabric-application-life cycle](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-lifecycle)。
*   您可以开发高度可靠、无状态和有状态的微服务。

有不同的服务结构编程模型，超出了本章的范围。更多信息请参考:[https://docs . Microsoft . com/en-us/azure/service-fabric/service-fabric-choose-framework](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-choose-framework)。

# 摘要

在这一章中，我们详细讨论了微服务架构风格，它的历史，以及它与它的前辈单片和 SOA 的区别。我们进一步定义了 monolithic 在处理大型系统时面临的各种挑战。可伸缩性和可重用性是 SOA 相对于单一架构的一些明显优势。我们还讨论了单芯片架构的局限性，包括通过实现真实的单芯片应用程序的扩展问题。微服务架构风格通过减少代码相关性和隔离任何一个微服务工作的数据集大小来解决所有这些问题。为此，我们利用了依赖注入和数据库重构。我们进一步探索了自动化、配置项和部署。这些很容易让开发团队让业务发起人选择首先响应什么行业趋势。这将带来成本效益、更好的业务响应、及时的技术采用、有效的扩展以及消除人员依赖。最后，我们讨论了 Azure 服务结构，并了解了服务结构及其不同的编程模型。

在下一章中，我们将继续将我们现有的应用程序转换为微服务风格的体系结构，并对我们的知识进行测试。