# 十、创建完整的微服务解决方案

在我们理解微服务及其发展的旅程中，我们经历了不同的阶段。我们探讨了是什么导致了微服务的出现以及利用它们的各种优势。我们还讨论了各种集成技术和测试策略。让我们回顾一下到目前为止我们讨论过的所有内容:

*   测试微服务
*   安全
*   监视
*   缩放比例
*   反应性微服务

# 微服务之前的架构

微服务从未从一开始就被设计成现在的形式。相反，已经从其他形式的流行架构风格逐渐过渡到微服务。在微服务出现之前，我们拥有统治企业开发世界的整体架构和面向服务的架构。

在快速回顾微服务及其各种属性和优势之前，让我们深入研究一下这两个。

# 整体架构

单片架构已经存在了相当长的一段时间，它产生了独立的软件。NET 程序集。它由以下组件组成:

*   用户界面
*   业务逻辑
*   数据库访问

自给自足的代价是所有组件都是相互关联和相互依赖的。任何模块的微小变化都有可能影响整个软件。由于所有组件都以这种方式紧密耦合，因此有必要对整个应用进行测试。此外，如此紧密耦合的另一个后果是整个应用必须再次部署。让我们总结一下由于采用这种架构风格而面临的所有挑战:

*   大型相互依赖代码
*   代码复杂性
*   可量测性
*   系统部署
*   采用新技术

# 标准化的挑战。NET 堆栈

当涉及到铁板一块时，采用技术并不容易。这带来了一定的挑战。安全性、响应时间、吞吐率和技术采用是其中的一部分。这并不是说这种建筑风格不会用解决方案反击。挑战在于，在单片集成中，代码的可重用性非常低或根本不存在，这使得技术采用变得困难。

# 缩放比例

我们还讨论了如何扩展是一个可行的选择，但随着收益递减和费用增加。垂直和水平缩放各有利弊。纵向扩展似乎更容易开始:投资于信息技术基础设施，如内存升级和磁盘驱动器。然而，回归很快就停滞了。水平缩放不存在垂直缩放所需的停机时间的缺点。然而，超过一个点，水平回报的成本就变得太高了。

# 面向服务的架构

行业中另一个广泛使用的架构是**面向服务的架构** ( **SOA** )。这种体系结构是对单一体系结构的一种转变，并参与解决了前面部分提到的一些挑战。首先，它是基于服务的集合。提供服务是 SOA 的核心概念。

服务是向其他系统组件提供某些功能的一段代码、程序或软件。这段代码能够直接与数据库交互，或者通过其他服务间接与数据库交互。它是独立的，因此桌面和移动应用都可以轻松使用服务。

SOA 相对于单块架构的一些明显优势是:

*   可重复使用的
*   无国籍的
*   可攀登的
*   基于合同
*   升级能力

# 微服务风格的架构

除了 SOA 的一些明确优势之外，微服务还提供了一些额外的差异化因素，使它们成为明显的赢家。在核心，微服务被定义为完全独立于系统中的其他服务，并在其流程中运行。独立的属性要求在应用设计中有一定的原则和策略。它们提供的一些好处包括:

*   清晰的代码边界:这导致了更容易的代码更改。它的独立模块提供了独立的功能，这导致了一个微服务的变化，对其他微服务的影响很小。
*   易于部署:如果需要，可以一次部署一个微服务。
*   技术适应性:上述特性带来了这一备受追捧的优势。这允许我们在不同的模块中采用不同的技术。
*   负担得起的可扩展性:这允许我们只扩展选定的组件/模块，而不是整个应用。
*   分布式系统:这是隐含的，但这里需要提醒一句。确保异步调用使用良好，同步调用不会阻塞整个信息流。很好地使用数据分区。我们稍后再谈这个，所以现在不要担心。
*   快速的市场响应:在竞争激烈的世界中，这是一个明显的优势，因为如果您对新功能请求的响应缓慢或在系统中采用新技术，用户往往会很快失去兴趣。

# 微服务中的消息传递

这是另一个需要讨论的重要领域。微服务中主要使用两种主要的消息传递类型:

*   同步的
*   异步的

# 整体转变

作为我们练习的一部分，我们决定将我们现有的单片应用 FlixOne 转换为微服务风格的架构。我们看到了如何根据以下参数识别整料中的分解候选物:

*   代码复杂性
*   技术采用
*   所需资源
*   人类依赖性

除了技术独立性之外，它在成本、安全性和可扩展性方面也有明显的优势。这也使应用更加符合业务目标。

转换的整个过程需要您识别类似于微服务边界的接缝，您可以沿着这些接缝开始分离。你必须小心选择合适的参数。我们已经讨论了模块相关性、团队结构、数据库和技术是几个可能的候选者。处理主数据需要特别小心。这更多的是一种选择，您是希望通过单独的服务还是通过配置来处理主数据。你将是你的剧本的最佳评判者。微服务拥有自己的数据库的基本要求是，它删除了许多现有的外键关系。这就需要智能地选择事务处理策略来保持数据完整性。

# 集成技术

我们已经探索了微服务之间的同步和异步通信方式，并讨论了服务的协作风格。这些风格是基于请求/响应和事件的。虽然请求/响应在本质上似乎是同步的，但事实是，正是实现决定了集成风格的结果。另一方面，基于事件的风格纯粹是异步的。

当处理大量微服务时，我们利用集成模式来促进微服务之间的复杂交互是很重要的。我们探索了应用编程接口网关和事件驱动模式。

应用编程接口网关为您提供了大量服务，其中一些如下:

*   路由应用编程接口调用
*   验证应用编程接口密钥、JWT 令牌和证书
*   强制实现使用配额和费率限制
*   在不修改代码的情况下动态转换应用编程接口
*   设置缓存后端响应
*   出于分析目的记录调用元数据

事件驱动模式的工作原理是，一些服务发布它们的事件，一些服务订阅那些可用的事件。订阅服务只是根据事件及其元数据独立于事件发布服务进行反应。发布者不知道订阅者将要执行的业务逻辑。

# 部署

企业应用的整体部署具有挑战性，原因不止一个。拥有一个难以分解的中央数据库只会随着上市时间的增加而增加整体挑战。

对于微服务，情况非常不同。好处不仅仅是因为架构是微服务。相反，这是从最初阶段开始的规划。没有**持续交付** ( **CD** )和**持续集成** ( **CI** )就不能指望管理一个企业级的微服务。从早期阶段开始，对 CI 和 CD 的需求就非常强烈，如果没有它，生产阶段可能永远看不到曙光。

CFEngine、Chef、Puppet、Ansible 和 PowerShell DSC 等工具可帮助您用代码表示基础架构，并让您轻松地使不同的环境完全相同。Azure 在这方面可能是一个盟友:所需的快速和重复供应很容易得到满足。

与最接近的竞争对手虚拟机相比，容器可以更有效地满足隔离要求。我们已经探索了 Docker 作为容器化的热门候选之一，并看到了如何部署它。

# 测试微服务

我们都知道单元测试的重要性，以及为什么每个开发人员都应该编写单元测试。单元测试是验证有助于构建更大系统的最小功能的好方法。

然而，测试微服务并不像测试一个整体那样是一件常规的事情，因为一个微服务可能与许多其他微服务交互。在这种情况下，我们应该利用对实际微服务的调用来确保整个工作流正常工作吗？答案是否定的，因为这将使开发一个微服务依赖于另一个部分。如果我们这样做，那么拥有基于微服务的架构的整个目的就失去了。为了避免这种情况，我们将使用模拟和存根方法。这种方法不仅使测试独立于其他微服务，而且使数据库测试更加容易，因为我们也可以模拟数据库交互。

用单元测试来测试一个小的隔离功能，或者通过模仿外部微服务的响应来测试一个组件，都有它的范围，并且在这个范围内运行良好。然而，如果你已经在问自己关于测试大环境的问题，那么你并不孤单。集成测试和合同测试是测试微服务的下一步。

在集成测试中，我们关心外部微服务，并作为过程的一部分与它们进行通信。为此，我们模拟外部服务。我们在合同测试中更进一步，我们独立测试每个服务呼叫，然后验证响应。值得花时间研究的一个重要概念是消费者驱动的合同。请参考第 4 章*测试策略*，对此进行详细研究。

# 安全

单一身份验证和授权点的传统方法在整体架构中运行良好。但是，在微服务的情况下，您需要为每个服务都这样做。这将带来一个挑战，不仅要实现它，还要保持它的同步。

OAuth 2.0 授权框架和 OpenID Connect 1.0 规范结合在一起可以为我们解决这个问题。OAuth 2.0 描述了授权过程中涉及的所有角色，很好地满足了我们的需求。我们只需要确保选择了正确的资助类型；否则，安全性会受到损害。OpenID Connect 身份验证建立在 OAuth 2.0 协议之上。

**Azure 活动目录** ( **Azure AD** )是 OAuth 2.0 和 OpenID Connect 规范的提供者之一。这里的理解是，Azure AD 可以很好地与应用进行扩展，并且可以很好地与任何组织的 Windows Server Active Directory 进行集成。

正如我们已经讨论过的容器，理解容器非常接近主机操作系统的内核是非常重要和有趣的。保护他们是另一个不能被高估的方面。Docker 是我们考虑的工具，它通过最小特权原则提供必要的安全性。

# 监视

铁板一块的世界有它自己的一些优势。与微服务相比，监控和日志记录是更容易的领域之一。企业系统可能分布的微服务数量之多令人难以置信。

正如第 1 章*微服务简介*中所讨论的，在*微服务架构的先决条件*一节中，组织应该为深刻的变化做好准备。监测框架是这方面的关键要求之一。

与单一架构不同，在基于微服务的架构中，从一开始就非常需要监控。监控可以分类的原因有很多:

*   健康:我们需要先发制人地知道什么时候服务失败迫在眉睫。关键参数，如 CPU 和内存利用率，以及其他元数据，可能是即将发生故障的前兆，或者只是服务中需要修复的缺陷。试想一下，当数百名现场管理人员试图与潜在客户分担成本时，保险公司的费率引擎会过载并停止服务，甚至运行缓慢。这些天没人喜欢等。
*   可用性:可能会出现这样的情况:服务可能不会执行大量的计算，但是服务本身的最低可用性可能对整个系统至关重要。在这种情况下，我记得依赖于对监听器的 pings，监听器会等待几分钟，然后向系统管理员发送电子邮件。它适用于带有一两个待监控服务的单片计算机。然而，有了微服务，就有了更多的元数据。
*   性能:对于获得高流量的平台，如银行和电子商务，可用性本身并不能提供所需的服务。考虑到在很短的时间内，从几分钟到甚至几十秒钟，有多少人聚集在他们的平台上，性能不再是奢侈品。您需要知道系统是如何通过数据做出响应的，例如服务的并发用户，并将其与后台的健康参数进行比较。这可能会为电子商务平台提供在即将到来的假期之前决定是否需要升级的能力。为了更多的销售，你需要服务更多的人。
*   安全性:在任何系统中，您只能规划特定级别的弹性。不管一个系统设计得多好，总会有一些阈值，超过这个阈值，系统就会摇摇欲坠，从而导致多米诺骨牌效应。然而，有一个精心设计的安全系统可以很容易地避免拒绝服务和 SQL 注入攻击。在处理微服务时，这对于系统到系统来说非常重要。因此，在设置微服务之间的信任级别时，要三思而后行。我看到人们使用的默认策略是用微服务保护端点。然而，涵盖这一方面可以提高系统的安全性，值得花些时间。
*   审计:医疗保健、金融和银行是在相关服务方面具有最严格合规标准的几个领域。全世界都差不多。根据您所处理的法规遵从性类型，您可能需要将数据作为记录保留特定的一段时间，以特定的格式保存数据以便与监管机构共享，甚至与监管机构提供的系统同步。税收制度可能是另一个例子。对于分布式体系结构，您不想冒丢失与单个事务相关的数据记录集的风险，因为这将导致法规遵从性失败。
*   排除系统故障:我敢打赌，在很长一段时间内，这将是任何开始使用微服务的人的最爱。我记得最初的几天，我曾尝试对一个涉及两个 Windows 服务的场景进行故障排除。我再也没有想过推荐类似的设计。但是时代变了，科技也变了。

当向其他客户提供服务时，监控变得更加重要。在当今竞争激烈的世界中，无论成功还是失败，服务级别协议都是任何交易的一部分，都有与之相关的成本。有没有想过，无论发生什么，我们多么容易就认为微软 Azure 服务级别协议会成为现实？我已经习惯了，担心云资源可用性的客户提出的查询得到的回复是 99.9%的正常运行时间，甚至没有眨眼。

因此，除非您有信心在提供服务时与您的客户达成服务级别协议，否则他们不能指望您承诺相同的服务级别协议。事实上，没有 SLA 可能意味着您的服务可能不够稳定，无法提供服务。

# 监测挑战

在建立成功的监控系统之前，可能需要解决多个关键问题。这些需要被识别并分配一个解决方案。接下来讨论一些关键点。

# 规模

如果你有一个成功运行的系统，几十个微服务完美协调地组织成功的事务，那么你就赢得了第一场战斗。恭喜你！但是，如果您还没有插入必要的监控部分，则必须插入。理想情况下，这应该是第一步本身的一部分。

# 组件寿命

随着虚拟机和容器的使用，我们需要弄清楚哪些部分值得监控。当您查看通过监视这些组件生成的数据时，其中一些组件可能已经不存在了。因此，明智地选择要监控的信息变得极其重要。

# 信息可视化

有一些可用的工具，例如 AppDynamics 和 New Relic，可以让您可视化多达 100 个微服务的数据。然而，在现实应用中，这只是这个数字的一小部分。必须明确这些信息的目的，并围绕这些信息进行精心设计的可视化。这是我们可以选择逆向设计的一个领域。首先，考虑你想要的报告/可视化，然后看看它是如何被监控的。

# 监测战略

从监控开始，您可以考虑不同的常用策略来解决您的问题。一些常见的实现策略有:

*   应用/系统监控
*   实时用户监控
*   语义监控和合成交易
*   压型
*   端点监控

请记住，这些策略中的每一个都专注于解决特定的目的。一种可能有助于分析事务传播，另一种可能适用于测试目的。因此，在设计整个系统时，选择这些策略的组合是很重要的，因为仅仅使用一种策略是不能满足需求的。

# 可量测性

我们详细讨论了可伸缩性的 scale-cube 模型，并发现了每个轴上的伸缩意味着什么。注意 *x* 轴缩放是通过在多个实例和微服务用户之间使用负载平衡器来实现的。我们还看到了基于交易发起的 *z* 轴缩放是如何遭受一些缺陷的。

总的来说，微服务领域的扩展可以分为两个独立的领域:

*   基础设施
*   服务设计

# 基础设施扩展

虚拟机是微服务世界不可或缺的组成部分。作为微软 Azure 平台的一部分，这些功能使您能够毫不费力地执行这个看似复杂的任务。

通过与 Azure 自动缩放集成的缩放集功能，我们可以轻松管理一组相同的虚拟机。

自动缩放允许您为各种受支持的参数定义阈值，例如 CPU 使用率。一旦超过阈值，缩放设置就会生效，具体取决于参数是放大还是缩小。

这意味着，如果扩展集预测它需要添加更多虚拟机来应对增加的负载，它将继续这样做，直到阈值恢复正常。同样，如果对被管理资源的需求下降，它将决定从扩展集中删除虚拟机。对我来说，这听起来像是网络团队的和平。关于自动扩展的选项可以进一步探索，因为它能够处理复杂的扩展需求，在向内扩展或向外扩展时运行数百台虚拟机。

# 服务设计

在我们的微服务中，我们已经实现了每个微服务的数据隔离。然而，读写数据库的模式仍然是一样的。由于底层关系数据库实现 ACID 模型，这可能是一件代价高昂的事情。或者我们可以说，这种方法可以稍加修改，以不同的方式实现数据库读/写操作。

我们可以使用公共查询责任分离，也称为 CQRS，在我们的微服务中进行有效的设计更改。一旦模型级分离完成，我们将可以使用不同的策略来优化读写数据模型。

# 反应性微服务

在将我们的整体应用转换为微服务风格的架构时，我们取得了很好的进展。我们还简要地讨论了在我们的服务中引入反应特性的可能性。我们现在知道了反应式微服务的关键属性是什么:

*   响应性
*   弹性
*   自治的
*   消息驱动

我们还看到了反应式微服务的好处，也就是在管理微服务之间的通信时，我们的工作量减少了。这种优势不仅转化为工作量的减少，还转化为专注于执行业务逻辑的核心工作的能力，而不是试图应对服务间通信的复杂性。

# 绿地应用

现在让我们从头开始创建 FlixOne 书店。首先，我们将确定微服务及其功能，并确定服务间的交互。

我们的 FlixOne 书店将提供以下功能:

*   在现有书籍中搜索
*   根据类别过滤书籍
*   向购物车添加书籍
*   对购物车进行更改
*   从购物车下订单
*   用户认证

# 确定我们的服务范围

为了理解这些功能将如何映射为不同的微服务，我们需要首先了解支持它需要什么，以及什么可以组合成微服务。我们将看到数据存储将如何开始从微服务本身的窗口向外看。

# 图书列表微服务

让我们试着把搜索书籍的第一个功能分解开来。为了让我们的用户在商店中浏览图书，我们需要维护一个可供选择的图书列表。在这里，我们的第一个候选人被雕刻成一个微服务。图书目录服务不仅负责搜索可用的图书，还负责维护存放所有图书相关信息的数据存储。微服务应该能够处理系统中可用书籍所需的各种更新。我们称之为图书目录微服务。而且，它将拥有自己的图书数据存储。

# 图书搜索微服务

检查过滤书籍的下一个功能似乎属于图书目录微服务本身的范围。然而，说到这里，让我们通过质疑我们自己对业务领域的理解来证实这一点。我想到的问题与我们的用户将执行的所有搜索带来的影响有关。那么，图书搜索功能应该是一种不同的服务吗？这里的答案在于微服务应该有自己的数据存储。让图书目录和图书目录搜索功能作为不同的服务需要我们在两个不同的位置维护一个图书列表，这带来了额外的挑战，例如必须同步它们。解决方案很简单:拥有一个单一的微服务，如果需要，扩展和负载平衡图书目录微服务。

# 购物车微服务

下一个候选是由亚马逊等带来的网上购物革命而闻名，并由智能手机进一步推动的:购物车微服务。它应该让我们在最终决定结账并付款之前，在购物车中添加或删除书籍。毫无疑问，这是否应该是一个单独的微服务。然而，这带来了一个有趣的问题，即它是否处理产品的数据存储；它需要这样做，以便获得一些基本的细节，例如库存的可用性。跨服务访问数据存储是不可能的，因为这是微服务最基本的先决条件之一。我们问题的答案是服务间的沟通。一个微服务可以使用另一个微服务提供的服务。我们称之为我们的购物车微服务。

# 订单微服务

下一步是下订单的业务功能。当用户决定他们的购物车里有合适的书时，他们决定下单。此时，与订单相关的一些信息必须被确认/传达给其他各种微服务。例如，在确认订单之前，我们需要从图书目录中确认有足够的库存数量来完成订单。确认后，应该从图书目录中减少正确数量的项目。成功确认订单后，购物车也必须清空。

虽然我们的订单微服务听起来更普遍，并且与跨微服务不共享数据的规则相矛盾，但事实并非如此，我们很快就会看到这一点。所有操作都将在保持清晰边界的同时完成，每个微服务管理自己的数据存储。

# 用户认证

我们的最后一个候选是用户认证微服务，它将验证登录我们书店的客户的用户凭证。此微服务的唯一目的是确认提供的凭据是否正确，以限制未经授权的访问。这对于微服务来说似乎很简单；但是，我们必须记住这样一个事实，即如果您决定更改身份验证机制，将此功能作为任何其他微服务的一部分会影响多个业务功能。这种变化的形式可能是使用基于 OAuth 2.0 授权框架和 OpenID Connect 1.0 身份验证生成和验证的 JWT 令牌。

以下是微服务的最终候选列表:

*   图书目录微服务
*   购物车微服务
*   订单微服务
*   用户身份验证微服务

在下图中，我们可以看到四种服务，即目录、购物车、订单和身份验证:

![](img/f9ac8893-2bd9-446a-9cd9-d3a4530dcaea.png)

# 同步还是异步

在我们开始简单介绍微服务之前，这里有一个要点需要考虑。我们的微服务将相互通信，并且有可能它们将依靠响应来进一步发展。这给我们带来了一个困境，我们经历了所有的痛苦，忘记了心爱的铁板一块，然后陷入同样的情况，一个失败点可能是系统的级联崩溃。

# 图书目录微服务

这个微服务有六个主要功能，通过一个 HTTP 应用编程接口组件公开。这个 HTTP API 组件负责处理这些函数的所有 HTTP 请求。

这些功能是:

| **API 资源描述** | **API 资源描述** |
| `GET` / `api` / `book` | 获取可用书籍的列表 |
| `GET` / `api` / `book{category}` | 获取某个类别的图书列表 |
| `GET` / `api` / `book{name}` | 按名称获取图书列表 |
| `GET` / `api` / `book{isbn}` | 根据国际标准书号获得一本书 |
| `GET` / `api` / `bookquantity{id}` | 获取预定图书的可用库存 |
| `PUT` / `api` / `bookquantity{id, changecount}` | 增加或减少一本书的可用库存数量 |

下图是目录服务的可视化表格:

![](img/dd32657b-5aa1-4ca3-a92c-6ba3e0c8a338.png)

# 购物车微服务

该微服务将具有以下作为 HTTP 端点公开供使用的功能:

| **API 资源描述** | **API 资源描述** |
| `POST` / `api` / `book {customerid }` | 将特定的书籍添加到客户的购物车中 |
| `DELETE` / `api` / `book {customerid }` | 从顾客的购物车中取出书 |
| `GET` / `api` / `book{customerid}` | 获取客户购物车中的图书列表 |
| `PUT` / `api` / `empty` | 移除购物车中当前包含的所有书籍。 |

下图显示了购物车服务的所有支持表:

![](img/e99e8356-0ac3-45c3-8aff-442655e8f63d.png)

# 订单微服务

该微服务将具有以下作为 HTTP 端点公开供使用的功能:

| **API 资源描述** | **API 资源描述** |
| `POST` / `api` / `order {customerid }` | 获取客户购物车中的所有书籍，并为其创建订单 |
| `DELETE` / `api` / `order {customerid }` | 从顾客的购物车中取出书 |
| `GET` / `api` / `order{orderid}` | 获取所有书籍作为特定订单的一部分 |

下图描述了订单服务的所有表格:

![](img/598e49f5-aca5-46e7-86fe-02c2b447c065.png)

# 用户身份验证微服务

该微服务将具有以下作为 HTTP 端点公开供使用的功能:

| **API 资源描述** | **API 资源描述** |
| `GET` / `api` / `verifyuser{customerid, password}` | 验证用户 |

下面的屏幕截图显示了身份验证服务的用户表:

![](img/36041ba3-4ca1-4b99-b021-aec19d71dab0.png)

您可以查看应用源代码，并根据需要进行分析。

# 摘要

我们希望这本书能够向您介绍微服务风格架构的基本概念，并帮助您通过概念的清晰示例深入了解微服务的细微方面。最终的应用可供您仔细查看，并以自己的速度分析到目前为止所学的内容。我们祝你在运用本书所学的技能并将其应用于现实挑战时好运。